<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />





  <link rel="alternate" href="/atom.xml" title="YXX博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="JavaScript开发者们，现在得承认：我们有一个关于promise的问题。
不，这不是promise自身问题。采用A+ 规范定义的Promise是非常酷的。
在过去一年中我遇到的最大问题，正如我看到许多程序员为PouchDB API和重promise API挣扎，是这个：
我们当中许多人在使用promise没有真正明白它。
如果你很难相信，想想我最近在twitter上发的内容：
问题：这四个p">
<meta property="og:type" content="article">
<meta property="og:title" content="你真的搞懂Promise了吗？">
<meta property="og:url" content="http://yoursite.com/2017/10/14/are-you-rellay-understand-promise/index.html">
<meta property="og:site_name" content="YXX博客">
<meta property="og:description" content="JavaScript开发者们，现在得承认：我们有一个关于promise的问题。
不，这不是promise自身问题。采用A+ 规范定义的Promise是非常酷的。
在过去一年中我遇到的最大问题，正如我看到许多程序员为PouchDB API和重promise API挣扎，是这个：
我们当中许多人在使用promise没有真正明白它。
如果你很难相信，想想我最近在twitter上发的内容：
问题：这四个p">
<meta property="og:updated_time" content="2017-10-31T09:04:43.524Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你真的搞懂Promise了吗？">
<meta name="twitter:description" content="JavaScript开发者们，现在得承认：我们有一个关于promise的问题。
不，这不是promise自身问题。采用A+ 规范定义的Promise是非常酷的。
在过去一年中我遇到的最大问题，正如我看到许多程序员为PouchDB API和重promise API挣扎，是这个：
我们当中许多人在使用promise没有真正明白它。
如果你很难相信，想想我最近在twitter上发的内容：
问题：这四个p">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 你真的搞懂Promise了吗？ | YXX博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YXX博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                你真的搞懂Promise了吗？
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-14T14:10:01+08:00" content="2017-10-14">
              2017-10-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JavaScript开发者们，现在得承认：我们有一个关于promise的问题。</p>
<p>不，这不是promise自身问题。采用<a href="https://promisesaplus.com/" target="_blank" rel="external">A+ 规范</a>定义的Promise是非常酷的。</p>
<p>在过去一年中我遇到的最大问题，正如我看到许多程序员为PouchDB API和重promise API挣扎，是这个：</p>
<p>我们当中许多人在使用promise没有真正明白它。</p>
<p>如果你很难相信，想想我最近在twitter上发的<a href="https://twitter.com/nolanlawson/status/578948854411878400" target="_blank" rel="external">内容</a>：</p>
<p>问题：这四个promise的区别是什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>如果你知道这个答案，恭喜你是一个promise高手。你有权限停止阅读此博文。</p>
<p>相对其他99.99%的人你是在一个好公司。没有人回复我的推文可以解决这个问题。是的，尽管我写了这道谜题。</p>
<p>这个答案在文章的末尾，但是首先，我想开头解释下为什么promise如此诡异和为什么我们当中很多人像新手和专家一样绊倒在这个上。我将会提供我认为是一个奇特的视角，这是一个怪异的技巧，这使得明白promise。是的，看过这些后我真的确信这些不是非常难。</p>
<p>但首先，让我们挑战一些关于promise的常见问题。</p>
<h3 id="为什么会出现promise呢？"><a href="#为什么会出现promise呢？" class="headerlink" title="为什么会出现promise呢？"></a>为什么会出现promise呢？</h3><p>如果你阅读有关promise的文献，你可能经常会发现这个<a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf" target="_blank" rel="external">糟糕的金字塔</a>参考，一些逐渐出现到你的屏幕右下方的可怕回调代码。</p>
<p>promise确实解决了这个问题，但他不仅仅是缩进。正如在“<a href="http://youtu.be/hf1T_AONQJU" target="_blank" rel="external">回调地域救赎</a>”这个精彩的对话中所解释的那样，回调真正地问题是我们不能用return和throw语句。相反，我们程序的整个流程是这样：一个函数接着调用另一个函数。</p>
<p>事实上，回调做的某些事甚至非常的险恶：他夺走了我们在编程语言常见的程序堆栈。编写没有堆栈的代码非常像没有制动踏板的汽车：直到你需要它但它并不在时你会意识到多么的需要它。</p>
<p>promise的整个要点是当我们使用异步编程时将return、throw和堆栈用到了编程中。但是你必须知道如何正确使用promise以便利用它。</p>
<h3 id="新手错误"><a href="#新手错误" class="headerlink" title="新手错误"></a>新手错误</h3><p>有些人尝试解释promise成<a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" target="_blank" rel="external">一部漫画</a>，或者一个名词：“噢，它是你可以传递的代表异步值的东西”。</p>
<p>我没有发现那样的解释对我非常有帮助。对我来说，promise都是关于代码结构和流程的。所以我任务最好解决一些常见的错误，并展示如何去解决它们。“你现在是个新手、小孩，很快就会很专业”，在这个意思上我把这些问题称作新手错误。</p>
<p>扯下题外话，“promise”对不同的人意味着许多不同的东西，但是这篇文章的目的仅仅是在讨论官方规范，像现代浏览器中的<code>window.Promise</code>。但是不是所有的浏览器都有了<code>window.Promise</code>，这里会有一个好的兼容方法（polyfill），看看这个最小的兼容规范库<a href="https://github.com/calvinmetcalf/lie" target="_blank" rel="external">lie</a>。</p>
<h4 id="新手错误1：糟糕的promise金字塔"><a href="#新手错误1：糟糕的promise金字塔" class="headerlink" title="新手错误1：糟糕的promise金字塔"></a>新手错误1：糟糕的promise金字塔</h4><p>看看这个有很多基于promise API的PouchDB，我看到了很多不好的promise模式。最常见的坏习惯是这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachments: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'Pulled doc with id '</span> + element.doc._id + <span class="string">' and added to local db.'</span>);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err.name == <span class="string">'conflict'</span>) &#123;</span><br><span class="line">                localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">                    localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params"> resp</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// et cetera...</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>是的，事实证明你在用promise好像它是回调，这很像使用电动砂光机在锉你的指甲，但是你可以做到。</p>
<p>如果你认为这类错误仅限于完全的新手，你会惊讶我是从BlackBerry官方的开发者博客上拿到的代码！旧友的回调习惯很难改。（对开发这说声抱歉，但这个例子是有启发性的。）</p>
<p>一种更好的方式是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个称之为组合promise，是promise超级强大的地方之一。每个函数仅在前一个函数运行完后利用其promise的返回结果调用，以此类推。</p>
<h4 id="新手错误2：WTF，我怎么在promise中使用forEach-？"><a href="#新手错误2：WTF，我怎么在promise中使用forEach-？" class="headerlink" title="新手错误2：WTF，我怎么在promise中使用forEach()？"></a>新手错误2：WTF，我怎么在promise中使用<code>forEach()</code>？</h4><p>这是大多数人对promise了解开始奔溃的地方。一旦他们达到他们熟悉的forEach()循环（或者for循环，或者while循环），他们就不知道怎么与promise结合起来一起工作。所以他们写出像下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除所有的docs</span></span><br><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">        db.remove(row.doc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 天真的认为现在所有的docs已经移除了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码有什么问题呢？这个问题是第一个函数实际上返回<code>undefined</code>，意味着第二个函数不会等待<code>db.remove()</code>在所有docs调用完。事实上，它不会等待任何操作，并且可以在任何数量的docs被删除时执行。</p>
<p>这是一个特别隐密的问题，因为你可能没有注意到有什么错误，假设PouchDB足够快地删除这些docs以便UI被更新。这个问题只能在奇怪的竞争条件下弹出，或者在某些浏览器中这样几乎不可能调试。</p>
<p>所有这些不是你寻找的结构forEach()/for/while的内容不必关注。你仅需要使用Promise.all()：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在所有的docs都已经移除了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里发生了什么？基础上Promise.all()把一系列的promise作为输入，然后只有当其他promise中的每一个都解决时给出另一个已解决的promise。它与for循环异步等效。</p>
<p>Promise.all()将一个结果数组传递给下一个函数，这非常有用，例如如果您尝试从PouchDB获取多个东西。如果其所有子promise中的任何一个被拒绝，all()承诺也被拒绝，这更为有用。</p>
<h4 id="新手错误3：忘记添加-catch"><a href="#新手错误3：忘记添加-catch" class="headerlink" title="新手错误3：忘记添加.catch()"></a>新手错误3：忘记添加<code>.catch()</code></h4><p>这是另一个常见错误。很自信他们的promise永远不会抛出错误，许多开发人员忘记在他们的代码中添加一个.catch()。不幸的是，这意味着任何抛出的错误将被吞下，你甚至不会在控制台中看到它们。这可能是一个真正的痛苦调试。</p>
<p>为了避免这种讨厌的情况，我已经习惯了将以下代码添加到我的promise链中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</span><br></pre></td></tr></table></figure></p>
<p>即使你从来没预料过错误，添加一个catch()一直是谨慎的。如果你的假设是错误的，这将使你的生活更轻松。</p>
<h4 id="新手错误4：使用deferred"><a href="#新手错误4：使用deferred" class="headerlink" title="新手错误4：使用deferred"></a>新手错误4：使用<code>deferred</code></h4><p>这是我一直我看到的错误，我不愿在这里重复一遍，因为担心，像Beetlejuice，只是调用它的名字将出现更多的例子。</p>
<p>简而言之，promise有悠久的历史，并且JavaScript社区花了很长时间才能让他们正确。在早期，jQuery和Angular正在使用这种“延迟”模式，现在已经被ES6 Promise规范所取代，由实现这种规范“好的”库如Q，When，RSVP，Bluebird，Lie等等。</p>
<p>所以如果你在你的代码中写这个词（我不会再重复一遍，第三次了），你做错了。以下是如何避免这种情况。</p>
<p>首先，大多数promise库都为您提供了从第三方库中“引进”了promise。例如，Angular的$ q模块允许您使用$q.when()来包装非$q promise。所以Angular用户可以这样包装PouchDB promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then( <span class="comment">/* ... */</span>);  <span class="comment">// &lt;-- 这是你需要的所有代码</span></span><br></pre></td></tr></table></figure></p>
<p>另一种方法是使用<a href="https://blog.domenic.me/the-revealing-constructor-pattern/" target="_blank" rel="external">揭示构造器模式（revealing constructor pattern）</a>，对包装非promise api有用。比如包装一个像Node的fs.readFile()基于回调的API，你只需要这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="comment">/* .... */</span>);</span><br></pre></td></tr></table></figure></p>
<p>完成！我们已经击败了可怕的def … Aha，抓住了自己。:)</p>
<blockquote>
<p>更多的关于为什么这是一个反模式，请查看<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="external">Bluebird维基页面关于promise反模式</a>。</p>
</blockquote>
<h4 id="新手错误5：不使用return的副作用"><a href="#新手错误5：不使用return的副作用" class="headerlink" title="新手错误5：不使用return的副作用"></a>新手错误5：不使用<code>return</code>的副作用</h4><p>这段代码出现什么错误呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哎，我希望someOtherPromise（）已经解决了！</span></span><br><span class="line">    <span class="comment">// Spoiler警报：没有。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>好的，这是一个很好的一点，谈论你需要了解promise的一切。真的，这是一个奇怪的伎俩，一旦你明白了，就会阻止我所说的所有错误。你准备好了吗？</p>
<p>正如我之前所说，promise的魔力是他们给我们带回了我们宝贵的return和throw。但这实际上是什么样的呢？</p>
<p>每个promise给你一个then()方法（或者catch()，这只是then(null, …)的语法糖）。这里我们在一个then()函数里面：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我在一个then函数里面</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这儿我们该怎么办？有三件事情：</p>
<p>1、return另一个promise<br>2、return一个同步值（或者undefined）<br>3、throw一个同步错误</p>
<p>就这些。一旦了解这个特招，你就明白了promise。那么让我们一次一个个地去看每个点。</p>
<h5 id="1、return另一个promise"><a href="#1、return另一个promise" class="headerlink" title="1、return另一个promise"></a>1、return另一个promise</h5><p>这是你在promise文献中看到的常见模式，如上面的“组合promise”示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获取了一个用户帐户！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意我return了第二个promise——return至关重要。如果我没有返回，那么getUserAccountById（）实际上会是一个副作用，下一个函数将会接收到undefined而不是userAccount。</p>
<h5 id="2、return一个同步值（或者undefined）"><a href="#2、return一个同步值（或者undefined）" class="headerlink" title="2、return一个同步值（或者undefined）"></a>2、return一个同步值（或者undefined）</h5><p>返回undefined通常是一个错误，但是返回一个同步值实际上是将同步代码转换为promise代码的好方法。例如，假设我们有一个用户的内存缓存。我们可以做的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获取了一个用户帐户！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>不是很棒吗？第二个函数不关心userAccount是同步还是异步地获取，第一个函数可以自由返回同步或异步值。</p>
<p>不幸的是，不方便的事实是JavaScript中的非返回函数在技术上返回undefined，这意味着当您意图返回某些东西时，很容易意外引入副作用。</p>
<p>因此，我将它作为个人习惯，总是从then()函数return或throw。我建议你做同样的事情。</p>
<h5 id="3、throw一个同步错误"><a href="#3、throw一个同步错误" class="headerlink" title="3、throw一个同步错误"></a>3、throw一个同步错误</h5><p>说到throw，这是promise可以得到更棒的地方。假设我们要抛出同步错误，以防用户注销。这很容易：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">//抛出一个同步错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// 返回一个同步值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// 返回一个promise！</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获得一个用户帐户！</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 嘘，出现错误！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果用户注销，我们的catch()将收到同步错误，如果有任何promise被拒绝，它将收到异步错误。同样，该函数不关心其获取的错误是同步还是异步。</p>
<p>这是特别有用的，因为它可以帮助识别开发过程中的编码错误。例如，如果在then()函数内的任何一点，我们做一个JSON.parse()，如果JSON无效，它可能会引发同步错误。使用回调，这个错误会被吞噬，但是有了承诺，我们可以在我们的catch()函数中简单的处理它。</p>
<h3 id="高级错误"><a href="#高级错误" class="headerlink" title="高级错误"></a>高级错误</h3><p>好吧，现在你已经学会了让promise变得简单的一个技巧，让我们来谈谈边缘案例。当然，总是有边缘的情况。</p>
<p>我把这些错误归类为“高级”，因为我只看过他们已经很熟悉promise的程序员了。但是，如果我们想要解决我在这篇文章开头提出的难题，我们将需要讨论它们。</p>
<h4 id="高级错误1：不知道Promise-resolve"><a href="#高级错误1：不知道Promise-resolve" class="headerlink" title="高级错误1：不知道Promise.resolve()"></a>高级错误1：不知道<code>Promise.resolve()</code></h4><p>如上所示，promise对于将同步代码作为异步代码来说非常有用。但是，如果您发现自己键入很多：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure></p>
<p>这对于捕获任何同步错误也是非常有用的。这是非常有用的，我已经习惯了开始几乎所有的promise-returning的API方法，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        doSomethingThatMayThrow();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">    &#125;).then(<span class="comment">/* ... */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要记住：对于在某处几乎不可能调试的吞咽错误，任何可能同步throw的代码是一个很好的候选对象。但是如果你把所有内容都包含在Promise.resolve()中，那么你可以随时确定catch()。</p>
<p>同样，有一个Promise.reject()可以用来返回一个立即被拒绝的承诺：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="高级错误2：catch-与then-null-并不完全一样"><a href="#高级错误2：catch-与then-null-并不完全一样" class="headerlink" title="高级错误2：catch()与then(null, ...)并不完全一样"></a>高级错误2：<code>catch()</code>与<code>then(null, ...)</code>并不完全一样</h4><p>我上面说的catch()只是语法糖。所以这两个片段是等价的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是，这并不意味着以下两个片段是等效的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果您想知道为什么它们不相等，请考虑如果第一个函数抛出错误会发生什么：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 捕捉到错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 没有捕获到错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>事实证明，当您使用then(resolveHandler, rejectHandler)格式时，如果resolveHandler本身抛出，rejectHandler将不会实际捕获错误。</p>
<p>因此，我已经习惯了不要再使用then()第二个参数，并且总是喜欢catch()。例外情况是当我正在编写异步<a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a>测试时，我可以在其中写一个测试来确保抛出错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I except an error!'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        should.exist(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>说到这一点，<a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a>和<a href="http://chaijs.com/" target="_blank" rel="external">chai</a>是一个可爱的组合来测试承诺的API。 <a href="https://github.com/pouchdb/plugin-seed" target="_blank" rel="external">pouchdb-plugin-seed</a>项目有一些可以让您开始的<a href="https://github.com/pouchdb/plugin-seed/blob/master/test/test.js" target="_blank" rel="external">示例测试</a>。</p>
<h4 id="高级错误3：promise和promise工厂"><a href="#高级错误3：promise和promise工厂" class="headerlink" title="高级错误3：promise和promise工厂"></a>高级错误3：promise和promise工厂</h4><p>假设你想按顺序执行一系列的promise。那就是你想要的是Promise.all()，但是并不执行这些承诺。</p>
<p>你可能会天真地写这样的东西：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resut = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">        result = result.then(promise);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不幸的是，这不符合你的意图。您传递给executeSequentially()的promise仍将并行执行。</p>
<p>发生这种情况的原因是，你不想在一系列promise上操作。根据promise规范，一旦promise创建，它将开始执行。所以你真正想要的是一系列的promise工厂：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">        result = result.then(promiseFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我知道你在想什么：“这个Java程序员究竟是谁，他为什么在谈论工厂？”一个promise工厂很简单，但它只是一个返回promise的功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么这样工作？起作用的是因为一个promise的工厂直到被要求才产生promise。它的工作方式与then的功能相同 - 事实上，它是一回事！</p>
<p>如果你看看上面的executeSequentially()函数，然后想象myPromiseFactory被替换为result.then(…)，那么希望一个灯泡会点醒你的大脑。在那一刻，你将会实现有promise的启示。</p>
<h4 id="高级错误4：好的，如果我想要两个promise的结果呢？"><a href="#高级错误4：好的，如果我想要两个promise的结果呢？" class="headerlink" title="高级错误4：好的，如果我想要两个promise的结果呢？"></a>高级错误4：好的，如果我想要两个promise的结果呢？</h4><p>通常情况下，一个promise将取决于另一个promise，但我们希望这两个promise的输出。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 危险，我也需要“user”对象！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>想要成为好的JavaScript开发人员，并避免使用金字塔，我们可能只将用户对象存储在更高作用域的变量中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    user = result;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 好了，我同时拥有“user”和“userAccount”</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个能够运行，但我个人觉得有点凑巧。我推荐的策略：放开你的先入为主并拥抱金字塔：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUerAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 好了，我同时拥有“user”和“userAccount”</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>…至少，暂时的如果缩进成为一个问题，那么您可以做JavaScript开发人员自古以来一直在做的工作，并将该功能提取到一个命名的函数中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">    .then(onGetUser)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在这一点上，doSomething()完成，我们回到0缩进</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>随着您的promise代码开始变得越来越复杂，您可能会发现自己将越来越多的函数提取到命名函数中。我发现这会导致非常美观的代码，可能看起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn()</span><br><span class="line">    .then(putYourRightFootOut)</span><br><span class="line">    .then(putYourRightFootIn)</span><br><span class="line">    .then(shakeItAllAbout);</span><br></pre></td></tr></table></figure></p>
<p>这就是promise的一切。</p>
<h4 id="高级错误5：promise破坏"><a href="#高级错误5：promise破坏" class="headerlink" title="高级错误5：promise破坏"></a>高级错误5：promise破坏</h4><p>最后，当我介绍上面的promise难题时，这是我提到的错误。这是一个非常深奥的用例，它可能永远不会出现在你的代码中，但它确实让我感到惊讶。</p>
<p>你认为这个代码打印出来什么？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果你认为打印出来bar，你是错误的。它实际上打印出foo！</p>
<p>发生这种情况的原因是因为当你传递then()一个非函数（如承诺）时，它实际上将它解释为then(null)，这导致先前的promise的结果通过。你可以自己测试一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>添加尽可能多的then(null)；它仍然会打印foo。</p>
<p>这实际上回到了我说promise vs promise工厂的前一点。简而言之，您可以直接将promise直接传递给then()方法，但不会执行您的想法。那么then()应该是一个函数，所以很可能你打算做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这将像我们预期的那样打印bar。</p>
<p>所以只是提醒自己：总是传递一个函数到then()！</p>
<h3 id="解决谜题"><a href="#解决谜题" class="headerlink" title="解决谜题"></a>解决谜题</h3><p>现在我们已经学到了所有有关promise（或接近它）的知识，我们应该能够解决我最初在这篇文章开始时提出的难题。</p>
<p>这是每道题的答案，以图形格式，所以你可以更好地可视化它：</p>
<h4 id="谜题1"><a href="#谜题1" class="headerlink" title="谜题1"></a>谜题1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题2"><a href="#谜题2" class="headerlink" title="谜题2"></a>谜题2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                  finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题3"><a href="#谜题3" class="headerlink" title="谜题3"></a>谜题3</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse())</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">|---------------------------------|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题4"><a href="#谜题4" class="headerlink" title="谜题4"></a>谜题4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse)</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure></p>
<p>如果这些答案仍然没有弄明白，那么我建议您重新阅读这篇文章，或者定义doSomething()和doSomethingElse()方法，并在浏览器中自行尝试。</p>
<blockquote>
<p>说明：对于这些例子，我假设doSomething()和doSomethingElse()都返回promise，并且这些promise代表了JavaScript事件循环之外的事情（例如IndexedDB，network，setTimeout），这就是为什么它们在适当时显示为并发。这是一个<a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="external">JSBin</a>来演示。</p>
</blockquote>
<p>对于更高级的promise使用，请查看我的<a href="https://gist.github.com/nolanlawson/6ce81186421d2fa109a4" target="_blank" rel="external">promise提示表</a>。</p>
<h3 id="关于promise的后话"><a href="#关于promise的后话" class="headerlink" title="关于promise的后话"></a>关于promise的后话</h3><p>promise是伟大的。如果您仍然使用回调，我强烈建议您切换到承诺。您的代码将变得更小，更优雅，更容易理解。</p>
<p>如果你不相信我，这里就是证明：<a href="https://t.co/hRyc6ENYGC" target="_blank" rel="external">PouchDB的map/reduce模块的重构</a>使用promise替代callback。结果：290次插入，555次删除。</p>
<p>顺便说一下，写那个讨厌的回调代码的人是…我！所以这是作为我的promise的原始力量的第一课，我感谢其他PouchDB贡献者一路上教导我。</p>
<p>话虽如此，promise并不完美。这是真的，他们比回调更好，但这是一个很好的说，一个打在肠道比一个踢在牙齿更好。当然，一个比另一个更好，但是如果你有一个选择，你可能会避免它们。</p>
<p>虽然优于回调，promise仍然难以理解和容易出错，这表现在我觉得不得不写这篇博文。新手和专家都会经常混淆这些东西，真的，这不是他们的错。问题在于promise虽然与我们在同步代码中使用的模式类似，但却是一个合适的替代品，但不完全相同。</p>
<p>实际上，你不应该学习一堆神秘的规则和新的API来做这些事情，在同步的世界里，你可以很好地完成熟悉的模式，如return，catch，throw和for-loop。不应该有两个并行的系统，你必须始终保持串行。</p>
<h3 id="期待async-await"><a href="#期待async-await" class="headerlink" title="期待async/await"></a>期待async/await</h3><p>这就是我在<a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="external">“用ES7驯服异步野兽”</a>中所做的一点，我在那里探索了ES7 async/await关键字，以及如何将承诺更深入地融入到语言中。 ES7可以让我们使用真正的try / catch / return关键字，就像我们在CS 101中学到一样，而不必编写伪同步代码（使用一种类似于catch的假捕获()方法，但不是真的）。</p>
<p>这是JavaScript作为一种语言的巨大福音。因为最后，只要在我们犯了错误时我们的工具不会告诉我们，这些承诺的反模式仍然会继续发生。</p>
<p>以JavaScript的历史为例，我认为说<a href="http://jslint.com/" target="_blank" rel="external">JSLint</a>和<a href="http://jshint.com/" target="_blank" rel="external">JSHint</a>比<a href="http://amzn.com/0596517742" target="_blank" rel="external">《JavaScript: The Good Parts》</a>更好的服务于社区，即使它们有效地包含了相同的信息。被告知你刚刚在你的代码中所犯的错误，而不是阅读一本你试图了解别人的错误的书。</p>
<p>ES7 aynsc/await的美妙之处在于，在大多数情况下，您的错误会将自己显示为语法/编译器错误，而不是微妙的运行时错误。在此之前，掌握了ES5和ES6中的promise能力，以及如何正确使用它们。</p>
<p>所以，当我认识到，像《JavaScript：The Good Parts》，这个博客文章只能有一个有限的影响，当你看到他们犯同样的错误希望你可以指出。因为我们还有太多人只需要承认：“我有promise的问题！”</p>
<blockquote>
<p>更新：有人指出，Bluebird 3.0将打印出可以防止我在这篇文章中发现的许多错误的警告。所以使用Bluebird是另一个很好的选择，而我们期待ES7！<br>现在ES 2017已经发布了规范，实现了async/await特性，激动人心！</p>
</blockquote>
<p>本篇文章翻译自 <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a>。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag">#JavaScript</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/07/the-revolution-of-web-development-2016/" rel="next" title="Web开发演化">
                <i class="fa fa-chevron-left"></i> Web开发演化
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/01/what-is-new-in-node-js-8-and-node-js-9/" rel="prev" title="Node.js 8和Node.js 9的新功能">
                Node.js 8和Node.js 9的新功能 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="yunxiange" />
          <p class="site-author-name" itemprop="name">yunxiange</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么会出现promise呢？"><span class="nav-number">1.</span> <span class="nav-text">为什么会出现promise呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新手错误"><span class="nav-number">2.</span> <span class="nav-text">新手错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新手错误1：糟糕的promise金字塔"><span class="nav-number">2.1.</span> <span class="nav-text">新手错误1：糟糕的promise金字塔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新手错误2：WTF，我怎么在promise中使用forEach-？"><span class="nav-number">2.2.</span> <span class="nav-text">新手错误2：WTF，我怎么在promise中使用forEach()？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新手错误3：忘记添加-catch"><span class="nav-number">2.3.</span> <span class="nav-text">新手错误3：忘记添加.catch()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新手错误4：使用deferred"><span class="nav-number">2.4.</span> <span class="nav-text">新手错误4：使用deferred</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新手错误5：不使用return的副作用"><span class="nav-number">2.5.</span> <span class="nav-text">新手错误5：不使用return的副作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、return另一个promise"><span class="nav-number">2.5.1.</span> <span class="nav-text">1、return另一个promise</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、return一个同步值（或者undefined）"><span class="nav-number">2.5.2.</span> <span class="nav-text">2、return一个同步值（或者undefined）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、throw一个同步错误"><span class="nav-number">2.5.3.</span> <span class="nav-text">3、throw一个同步错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级错误"><span class="nav-number">3.</span> <span class="nav-text">高级错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高级错误1：不知道Promise-resolve"><span class="nav-number">3.1.</span> <span class="nav-text">高级错误1：不知道Promise.resolve()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级错误2：catch-与then-null-并不完全一样"><span class="nav-number">3.2.</span> <span class="nav-text">高级错误2：catch()与then(null, ...)并不完全一样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级错误3：promise和promise工厂"><span class="nav-number">3.3.</span> <span class="nav-text">高级错误3：promise和promise工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级错误4：好的，如果我想要两个promise的结果呢？"><span class="nav-number">3.4.</span> <span class="nav-text">高级错误4：好的，如果我想要两个promise的结果呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高级错误5：promise破坏"><span class="nav-number">3.5.</span> <span class="nav-text">高级错误5：promise破坏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决谜题"><span class="nav-number">4.</span> <span class="nav-text">解决谜题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#谜题1"><span class="nav-number">4.1.</span> <span class="nav-text">谜题1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谜题2"><span class="nav-number">4.2.</span> <span class="nav-text">谜题2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谜题3"><span class="nav-number">4.3.</span> <span class="nav-text">谜题3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谜题4"><span class="nav-number">4.4.</span> <span class="nav-text">谜题4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于promise的后话"><span class="nav-number">5.</span> <span class="nav-text">关于promise的后话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#期待async-await"><span class="nav-number">6.</span> <span class="nav-text">期待async/await</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yunxiange</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
