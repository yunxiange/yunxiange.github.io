<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[我的2017]]></title>
      <url>http://yoursite.com/2017/12/30/summary-of-2017/</url>
      <content type="html"><![CDATA[<p>眨眼间就到年底了，回顾这一年走过的痕迹，总结下自己做过什么和收获什么，从工作、生活两方面理一下过往。</p>
<h3 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h3><p>年初我从原来的部门trans到新的部门，毕业以来第一次换了一个新的环境，学习新的业务和接触不同的技术方案，走出个人舒适区。</p>
<p>新业务与原来的业务有很多相似之处，比如管理端都有投放功能和数据分析功能，有些运用了类似的实现方案。最大的不同点是新业务属于跨团队业务，往往一个需求点需要与两三个端打交道，各种数据通信，考验个人沟通能力和解决问题能力。</p>
<p>先说一下如何快入了解新业务及其上手。一般团队都会有相应的wiki可供参考，当然程序员之间沟通最直接的还是以源码方式。在上手前一定要认真查看相应的文档内容，一般都包含有哪些业务内容、如何搭建业务环境、如何开发部署上线等等。搭建业务环境是最基础的工作，这种新的业务模块自己只是接触其中的一个环节，但是需要将其他的模块也安装好，方便开发调试。在这个过程中Linux环境、Mock数据模拟、Postman调试、Charles代理、Node.js、Git版本管理都有很好的接触和运用。环境搭建好了就可以看看实际的运行效果，理解整个流程的运行原理。</p>
<p>上半年主要是做小频道的广告，需要了解物料、模板配置与实现、小流量等内容。这种业务是根据上游环境需要返回具体的模板内容，分为html和json两种格式内容。比较耗时的是各个端的环境连通和计费。环境连通问题有可能是环境没有跑起来、环境之间的连接方式不对、环境之间连接超时、环境跑不出数据等原因，善于去查看各个端的log内容以便高效地解决问题。计费问题需要考虑上游端的环境机制，运用同步还是异步方式，代码规范是否有特定的要求。为了让自己负责的模块能够在联调前看到可视化效果，针对一跳广告和二跳广告基于Node.js做服务转发，提前调整样式内容和验证内部样式叠加逻辑，减少在同上游联调过程中出现一些不依赖实际环境的代码问题。</p>
<p>下半年主要是做Feed流的广告模板迁移与解耦。模板渲染方式由PHP渲染变成Node.js渲染，一方面应对业务需求发展，另一方面解决历史遗留的模块耦合问题。Smarty模板转成Node.js模板，灵活性增强，开发维护更方便。之前的模板全部放在一个代码库下，现在拆分成按各个产品线来划分模板代码库，开发上线互不影响。迁移过程中需要保留每一个模板逻辑和一致的输出内容，根据物料类别和数据源信息找到对应的模板内容。迁移过程中主要遇到的问题是数据不能打平，一方面是代码疏忽，比如默认字符缺失、字符类型不一致、逻辑判断遗漏，另一方面是PHP平台和Node.js平台实用方法不一致引起的。模板迁移完又对模板进行了一次升级，将物料模板拆分成以数据源为个体单位，验证过程中开发了一套diff输出数据工具。</p>
<p>平时在工作中会遇到大大小小的问题，最终都以各种方式和途径解决了，这个过程中要形成自我的思维方式和能力：快速学习能力、问题定位能力、问题解决能力、高效沟通能力、善于开发工具解决重复的问题和提高开发效率。</p>
<h3 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h3><p>个人平时的兴趣爱好是阅读与健身，身体和灵魂总有一个在路上。偶尔玩一下象棋和其他小游戏，放松身心。</p>
<p>  培根曾说过：“读史使人明智，读诗使人灵秀，数学使人周密，物理使人深刻，伦理使人庄重，逻辑与修辞使人善辩。” 今年陆续在微信读书app上看了几本书和一些纸质版书。微信读书上看书时长还不到每天一个小时，今后要努力保证一天一到两个小时时间阅读，接触得越多发现懂得越少。细数看过的书类别繁多，分为技术类和非技术类，非技术类主要包含历史、经济、文学、励志。</p>
<p>技术类书籍：</p>
<ul>
<li>《JavaScript权威指南（第六版）》（重温）</li>
<li>《ECMAScript 6 入门》</li>
<li>《图解HTTP》</li>
<li>《深入浅出React和Redux》</li>
<li>《深入浅出Node.js》</li>
</ul>
<p>非技术类书籍：</p>
<ul>
<li>《把时间当作朋友》（重温）</li>
<li>《穷查理宝典：查理芒格智慧箴言录》</li>
<li>《一本书读懂财报》</li>
<li>《穷爸爸富爸爸》</li>
<li>《罗辑思维（全集）》</li>
<li>《你只是看起来很努力》</li>
<li>《你的善良必须有的锋芒》</li>
<li>《一平米健身：硬派健身》</li>
<li>《精神的故乡》</li>
</ul>
<p>以上的书籍都看完了，在读的书籍有《明朝那些事儿（全集）》、《中国通史（全集）》、《看见》、《白说》。</p>
<p>关于健身这里想说两句，健身和做其他事一样需要坚持和耐心。每次训练时力求每个动作到位、每个动作集中注意力且不能快，调整呼吸和训练重量。</p>
<p>“读万卷书不如行万里路,行万里路不如阅人无数,阅人无数不如名师指路,名师指路不如自己去悟。” 去过的城市有北京、常德、广州、随州、杭州，有的是出差、学习、交流，有的是办事，有的是游玩。</p>
]]></content>
      
        
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[参加D2 2017是怎样一种体验？]]></title>
      <url>http://yoursite.com/2017/12/19/d2-2017/</url>
      <content type="html"><![CDATA[<p>个人参加D2这次是第三次了，每次从上海出发到达杭州，前两次分别是14年和15年。D2大会见证了前端蓬勃发展，每年的话题各不一样，嘉宾演讲内容来源于当下的项目实践和思考，紧跟当前技术发展潮流。</p>
<h2 id="现场体验"><a href="#现场体验" class="headerlink" title="现场体验"></a>现场体验</h2><p><a href="http://d2forum.alibaba-inc.com" target="_blank" rel="noopener">D2前端技术论坛</a>是Designer &amp; Developer Frontend Technology Forum的简称，从2007年由阿里巴巴举办第一届大会以来，陆续举办了十二届前端大会，今年是大会成立十周年。会议开场由淘宝几个伙伴组建的996乐队激情演绎了原创歌曲《孤独的心 孤独的路》，活跃了现场气氛。接着主持人推出生日蛋糕庆祝大会成立十周年，虽然现场没有响起未准备好的生日歌，但这个仪式已经足足表达了大会一路走来的历程。</p>
<p>大会结束两三天了，是时候总结这次参加大会的感受。</p>
<h2 id="话题交流"><a href="#话题交流" class="headerlink" title="话题交流"></a>话题交流</h2><p>今年D2主要参加的话题有：</p>
<ul>
<li>上午场<ul>
<li>360奇舞团月影大大的《自我成长的多元化团队》</li>
<li>阿里信息平台熟米的《阿里智慧园区平台前端与IoT结合技术实践》</li>
<li>阿里盒马岑安的《愿⻛裁尘，以⼼御匠——前端作为技术⼈的思考》</li>
</ul>
</li>
<li>下午场<ul>
<li>哔哩哔哩戴天宇的《现代前端对视觉和交互的探索》</li>
<li>腾讯田淮仁的《PWA带来极速离线Web》</li>
<li>360奇舞团胡尊杰的《H5-Video实践》</li>
<li>阿里云剪巽的《Node.js微应用实践》</li>
</ul>
</li>
<li>夜场<ul>
<li>阿里天猫舒文的《天猫前端圆桌交流会》</li>
</ul>
</li>
</ul>
<h3 id="《自我成长的多元化团队》"><a href="#《自我成长的多元化团队》" class="headerlink" title="《自我成长的多元化团队》"></a>《自我成长的多元化团队》</h3><p>看到这个演讲标题脑海中想到这是一个与管理、个人／团队成长相关的话题，一般这个话题都会比较抽象，但听完整个演讲后脑海中对在一个团队中如何成长、如何突破有了更加清晰的认识。</p>
<p>月影演讲一开始抛出了两个问题：作为一名技术管理者需要具备哪些能力？技术管理者的价值是什么？</p>
<p>带着这些疑问先从介绍奇舞团当前现状说起，奇舞团是一个全栈业务团队，涉猎的方向包含基础服务／技术研究、中台、产品线，一个团队会首先从产品线业务入手，逐渐剥离业务沉淀技术服务，才会出现中台、基础服务／技术研究的技术支撑业务。奇舞团是一个重组织轻管理的团队，由团队扩大成组织从而形成影响力，打造影响力闭环需要输入和输出，这些依赖众成翻译平台提供素材打造了奇舞周刊、图书翻译，从而形成影响力。</p>
<p>管理就等于“搞人”吗？团队会为高潜员工培养提供职业发展，会有泛前端分享会为新人培训。对于外部人员提供了星计划和特训营服务，形成校园合作。一个好的组织具有多维度成长空间，每个人总能从中找到自己感兴趣擅长的角色，随着技术和业务能力提升，组织会出现接口人、管理岗、技术骨干、出品人、面试官、导师、讲师、译者等角色。组织通过以人驱动技术革新、以技术革新改变工具、以工具创造平台、以平台服务产品来提升效能。团队的话语权来自于有效的合作、兑现承诺、专业产出、团队氛围、影响力和组织，而不是来自于职级和title、以上压下、强势及抢占、垄断资源。绩效管理应该服务于团队，而不是让团队去服务于KPI。团队往往会出现积极派和保守派，都会认同人是技术进步的关键因素、建立组织能够提升效能，积极派认为技术是价值投资、新技术带来潜力、管理的价值在于承担风险，保守派则认为技术落地于产品、新技术带来风险、管理的价值在于规避风险。</p>
<p>月影的“懒人管理”模式是不干涉技术选型、不限制技术栈、鼓励尝新、鼓励“不务正业”、鼓励交流和个人成长，具备对技术发展了如指掌、对所选技术栈深度了解、技术兜底把控风险、提升效率重视结果产出、技术晋升的要求等能力，这些能力培养来源于关注周刊和众成翻译、好奇心钻研精神、时间管理专业能力培养、分享会个人影响力管理。持久地对技术进行投资，面向框架／库、工具／服务、技术产品以及业务支持。</p>
<p>管理者应当做什么？对上管理、对下管理、协调资源、有效激励、后勤保障，建立有效的组织，认同技术是一种长线投资。管理者不应该限制团队的未来发展，而是让团队自己去选择，即使管理者离开这个团队，团队也能朝着前方奔跑。</p>
<p>个人归属于团队，但不依赖团队，能够找到自己的角色持久地对技术投资，提升各项能力形成个人影响力，支持技术产品和业务的发展。</p>
<h3 id="《阿里智慧园区平台前端与IoT结合技术实践》"><a href="#《阿里智慧园区平台前端与IoT结合技术实践》" class="headerlink" title="《阿里智慧园区平台前端与IoT结合技术实践》"></a>《阿里智慧园区平台前端与IoT结合技术实践》</h3><p>前端碰上物联网会产生怎样的火花？</p>
<p>首先介绍了物联网有芯有网的特点，物联网的整体技术结构，近年来物联网发展情况。IoT具有大、快、难的工程特点，面对传统嵌入式／系统集成开发偏低的开发效率与互联网行业高速的迭代需求之间的矛盾，然后引出了前端与IoT如何结合。具备技术栈优势、注重开发效率、有着完善的包管理与社区的前端在IoT时代能做些什么？可以做设备、服务和客户端。</p>
<p>设备开发，将前端开发模式搬到集成电路板上，阿里自研的RUFF类似jQuery语法面对设备编程。采用Node.js、serverless来进行服务开发，在更多样的载体上像非标设备、可穿戴设备、无屏设备开发更多样的功能。</p>
<p>介绍了天猫精灵的产品案例，通过语音路由命令驱动实现功能。然后以一个更加贴近实际办公生活的例子阿里智慧园区（IB）平台进一步阐述前端在物联网上的功能实现。IB的总体架构分为云端和前端，云端涌来存储设备数据和相关规则，前端通过ib-OS兼容各种设备自带的标准协议来控制海量终端。现在人工智能发展的概念越来越火，在实际中的应用案例也不少，这里列出了在车辆识别和人脸识别的扩展应用，使得日常的生活工作更加便利。</p>
<p>但是前端在物联网上出现了相应的转变和挑战，从“做页面”到“做服务”，从“面向数据库编程”到“面向数据编程”，从“增删改查”到“可视化”、“可操作化”以及系统集成部署问题。从做页面到做服务更多的是与数据打交道，开放数据、承载数据、在平台上提供一揽子服务。从面向数据库到面向数据需要实时数据和可控模型。从表单应用到可视化提供空间、数据以及流程的可视化。系统集成会遇到多种内网、分层网络环境带来的部署问题。</p>
<p>物联网在现实生活中越来越普及，服务多样化，小到一个芯片大到一个集成服务，在生活智能领域扮演了重要的角色，在这个演讲中分享了物联网开发特点和遇到的挑战，给这个领域的新人展示了一个独特的视角。</p>
<h3 id="《愿⻛裁尘，以⼼御匠——前端作为技术⼈的思考》"><a href="#《愿⻛裁尘，以⼼御匠——前端作为技术⼈的思考》" class="headerlink" title="《愿⻛裁尘，以⼼御匠——前端作为技术⼈的思考》"></a>《愿⻛裁尘，以⼼御匠——前端作为技术⼈的思考》</h3><p>演讲者是一个愿意去思考技术的无线研发工程师，前端技术会深入到某个技术点，也会横向扩展到工程、架构、性能领域，由前端延伸到各种无线终端实现，具备业务技术能力。整个演讲的思路是先介绍了前端发展的历程，回归技术人的本质；思考了技术为业务服务的“从点到线”的路径；总结了技术人成长的三个关键词；归纳了前端的核心竞争力，还原技术人的本质。</p>
<p>前端发展历程经历了Web 1.0、应用时代（MVC、SPA、MV**）以及云+端几个发展阶段，每一个阶段的出现都伴随着革新技术的出现，浏览器出现出现了各种技术规范引领Web 1.0时代，XMLHttpRequest出现使得前端进入到应用时代，Node.js出现前端应用扩展到云和终端。但每个阶段都会遇到许多问题和出现相应的解决方案。Web 1.0时代注重页面内容承载、排版、阅读体验，应用时代侧重框架、工程化、富交互与性能，云+端带来新的研发模式和面对新的业务场景。深入实践和思考形成大前端五大方向：企业中后台（组件、协议）、开发者服务、泛Node.js、端技术（Weex+Webview）和图形（可视化+互动能力）。</p>
<p>从业务到技术的思考路径有以下几个阶段：（1）需求和项目分阶段，连成线来看;（2）从过去的状态和问题推导下一阶段业务方向；（3）从下一阶段的业务挑战推导技术挑战；（4）从技术挑战拆解技术项目。演讲者通过一线业务实践阐述了各个阶段的切身体会：技术为业务服务需要“从点到线”，技术架构和领域模型需要“从面到点”。</p>
<p>技术人成长的三个关键词：做（有目标的做，分阶段的做，做到极致），思考（核心，why有时候比how更重要），发声（执行的总结，思考的传达）。关于“思考”的两方面：人和事，思考自己、思考团队和业务节奏、技术拆解。关于“做”：往往一接到事情就埋头扎到“怎么做”这个维度上，可是比方案更重的是“why”和“目标”。这里举了“稳定性”的例子说明怎么样去做。关于“发声”：本质是思考的传达和帮助自我梳理总结。</p>
<p>前端的核心竞争力基于各种各样的知识和技能对于业务和团队问题的拆解并输出解决方案且落地的综合能力。</p>
<h3 id="《现代前端对视觉和交互的探索》"><a href="#《现代前端对视觉和交互的探索》" class="headerlink" title="《现代前端对视觉和交互的探索》"></a>《现代前端对视觉和交互的探索》</h3><p>现在前端的视觉越来越人性化、交互越来越炫酷流畅，那么B站都做了些什么尝试呢？</p>
<p>首先展现了B站与往年不太一样的大型活动一些探索。第一个场景是<a href="https://bml.bilibili.com/2017/index.html#/guide" target="_blank" rel="noopener">BML2017</a>，为BML2017设计制作的主视<br>觉⻚⾯。运用了HTML5视频、Transition/SVG、Keyframes/ReactMotion、Canvas邀请函等技术实现动态效果。第二场景是<a href="http://www.bilibili.com/blackboard/double7.html" target="_blank" rel="noopener">Double;7</a>，为七夕⽽制作的GalGame游戏。GalGame包含了纯剧情向，对话主导，场景、立绘、音乐和动画效果，内容包含舞台（图层）、虚拟话剧、剧本（DSL），技术亮点是二维大画布、分格随机位置大小、陀螺仪、弹幕推送。第三个场景是<a href="http://www.bilibili.com/blackboard/preview/jingle-beats.html" target="_blank" rel="noopener">JingleBeats</a>，一个为圣诞而制作的音游。采用了谱面解析、节奏序列和仲裁函数生成、时间控制画面、事件系统发布订阅模型、基于Shader的效果等技术实现。</p>
<p>接着引出了当下思考，现在前端在做什么。现在的大多页面由文本、图像和流媒体构成，交互基本上都是以点击和键盘输入，最多加上一些简单手势。网页可以展示的内容随着时间的前进，根植于不断提高的基础设施，越来越丰富，最终使其拥有了制作近似于桌面应用的SPA的能力。发展到SPA后，甚至有了Electron、RN等，有了能制作桌面应用的能力后，前端的下一步是什么？</p>
<p>然后嘉宾带着我们开阔眼界，走出Web领域看看其他领域的发展情况。前端领域在⼯程化、⼤前端⽅向基本搬来了整个传统领域的解决⽅案，那么在视觉和交互⽅向是不是也能有所借鉴？桌面领域OpenGL／DX渲染十分成熟，大型游戏和VR的基石；移动领域也有OpenGL-ES以及丰富的传感器设备；机器学习在某些领域能够解决一些经典方法难以解决的问题；艺术领域也在寻求新的媒体介，新媒体艺术越来越火。新的媒介不断发展，如3D扩展空间维度、VR带来沉浸式体验、AR增强现实。多种多样的交互输入，手机上已经具备GPS、陀螺仪、摄像头/麦克风、触控功能。机器学习不断深入实践，海量数据加工提取的价值越来越大。艺术近年也向新的媒介发出了探索，新媒体艺术的参与者越来越多。</p>
<p>我们回来看看自身能做什么。Web基于浏览器可访问的资源构建起的应用系统。前端，本质实是⼀个“连接器”，利⽤可视化等技术，将⽤户⽆法理解的科技和内容⽤其可感知的⽅式呈现出来，即实现“⼈机接⼝”。Web前端，本质上是在浏览器这个平台上，实现⼈机接⼝的⼯程师。不断有新的基础设施落地，CSS3/WebGL、Sensors／WebRTC、GPU运算、工作于渲染线程之外的Workers。丰富的类库给开发门槛带来大幅下降，为复杂应用实现带来了极大便捷，比如<code>Three.js</code>使得3D图形开发门槛大幅下降，<code>PIXI</code>和<code>Egret</code>为2D复杂应用（游戏）带来了极大便捷，<code>Babylonjs</code>引擎让Web上的3D游戏成为可能，<code>ReactVR</code>降低了WebVR/AR门槛，<code>deeplearn.js</code>开启了前端机器学习的可能。Web形式不断演化，从单调展示、简单交互的静态页面发展到具有丰富视觉效果、丰富交互的SPA，进而进化到游戏形式，借助于wasm和asm.js当下一些著名游戏引擎（比如U3D、UE4）也逐渐支持渲染到WEB。</p>
<p>最后以一个复杂交互的DEMO（3D相册）将全场气氛带入了高潮。three.js实现场景渲染，光照、模型加载、阴影；physi.js实现物理引擎，raycaster实现捕获事件；WebVR标准实现VR模式，使用webvr-polyfill做兼容；PC（点击）、移动（触摸）、VR（陀螺仪）三级输入。</p>
<p>更多例子值得学习：</p>
<ul>
<li><a href="http://www.ebay-report.de/ebay-in-zahlen/" target="_blank" rel="noopener">http://www.ebay-report.de/ebay-in-zahlen/</a></li>
<li><a href="https://emmitfenn.com/" target="_blank" rel="noopener">https://emmitfenn.com/</a></li>
<li><a href="https://noheroes.ghostrecon.com/" target="_blank" rel="noopener">https://noheroes.ghostrecon.com/</a></li>
<li><a href="https://controltheweather.geostorm.movie/" target="_blank" rel="noopener">https://controltheweather.geostorm.movie/</a></li>
<li><a href="http://2017.makemepulse.com/" target="_blank" rel="noopener">http://2017.makemepulse.com/</a></li>
<li><a href="http://residente.com/" target="_blank" rel="noopener">http://residente.com/</a></li>
<li><a href="https://my.pottermore.com/hogwarts" target="_blank" rel="noopener">https://my.pottermore.com/hogwarts</a></li>
<li>……</li>
</ul>
<h3 id="《PWA带来极速离线Web》"><a href="#《PWA带来极速离线Web》" class="headerlink" title="《PWA带来极速离线Web》"></a>《PWA带来极速离线Web》</h3><p>PWA即Progressive Web Apps的简写，是Google提出的用前沿的Web技术为网页提供App般使用体验的一系列方案。相关浏览器产商目前对这套方案支持程度不一，这两天看到新闻最新发布的Safari 46技术预览版里，将默认打开支持PWA功能Service Worker，这意味着苹果正在逐步接受PWA，我们将进入PWA的时代。</p>
<p>回到这个演讲正题，体会PWA实践，内容分为四大块，分别为PWA尝鲜、离线缓存、SW离线包策略、未来规划。</p>
<p>PWA尝鲜这部分包含了PWA技术涉及的基础内容。PWA是由一系列方案构成的，分别是Service Worker、CacheStorage、WebPush和Manifest。Service Worker运行PWA的骨架，基于worker；Push像APP一样实现推送；Cache替代以前的manifest，实现灵活缓存；Manifest用来生成桌面ICON。Service Worker类似于Fiddler用来监听页面请求，接受后台Push，管理离线Cache资源，新开／聚焦页面。Service Worker基于Worker的难点在于域名限制和生命周期控制（初始注册、脚本更新、终止生效）。</p>
<p>离线缓存总结实践过程中SW加载时延和离线包的对比。常用存储有CacheStorage、IndexDB、LocalStorage、WebSQL，其中比较安全的缓存是CacheStorage。CacheStorage只能在同域中读取，支持promise API风格，完美结合fetch。这种缓存并不是能够随意存储任何大小的内容，受到浏览器的限制，不同浏览器的共享空间不一样，可通过大小检测（Quota Management API）来查看各个内存使用分布。使用LRU或者淘汰策略来移除溢出的缓存。缓存策略分为三种，分别是persistent（基本不修改，随Service Worker一起更新）、seldom（很少修改，N+1更新）、often（经常修改，不缓存）。</p>
<p>Service Worker离线包策略结合多种离线数据库，制定离线策略方法和方案。针对实际的应用场景需要离线包，采用灰度、增量部署、Push下发的方式来更新离线包。而Service Worker离线与LocalStorage存储灰度List、HTTP Last-Modified/E-tag缓存头和Push Message有关。离线包与Service Worker在更新方式、更新大小、返回效率、离线资源控制方面相比，Service Worker更新速度快，离线包文件小但覆盖很慢。没有离线包技术可以试一试Service Worker。</p>
<p>未来规划谈到了SW离线库优化和便捷库的提供。iv-pwa提供现成Service Worker缓存策略和library，方便接入灵活处理。iv-pwa-plugin提供webpack-plugin插件，适用于webpack构建项目接入PWA。WebPush实现Push动态更新。</p>
<h3 id="《H5-Video实践》"><a href="#《H5-Video实践》" class="headerlink" title="《H5-Video实践》"></a>《H5-Video实践》</h3><p>H5的Video实践，不就是一个Video标签用来展示视频内容吗？听完这场演讲后，从嘉宾的演讲内容会得到更多的答案。</p>
<p>首先介绍了Video标签基本应用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=<span class="string">"//chimee.org/vod/1.mp4"</span> controls&gt;</span><br><span class="line">  您的浏览器不支持Video标签。</span><br><span class="line">&lt;<span class="regexp">/video&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>H5视频容器支持的格式有好几种，MP4、OGG、WebM、M3U8等，但是它们在各浏览器上的支持程度不一样，MP4的支持程度较高。可以使用source标签来设置多个备用video源，根据容器类型兼容<code>canPlayType</code>判断浏览器是否支持某种格式及特定编码。</p>
<p>接着通过实例来展示Video的交互应用，可以通过JS API进行状态修改和事件监听响应状态的变化，配合<code>FileReader</code>播放本地文件、基于<code>WebRTC</code>播放摄像头视频流、基于<code>getUserMedia</code> API播放摄像头视频流、配合canvas实现人脸识别、配合<code>MediaRecorder</code> API实现视频录制、采用JS动态创建媒体源<code>MediaSource</code>，充分展示了Web前端可以做许多有趣的事情。</p>
<p>然而前端无法避免环境差异，在各环境中外观UI风格迥异、API实现参差不齐、事件交互表现各异、媒体解码能力莫衷一是。在实际媒体播放开发中也会遇到不能满足当前现状的种种问题：状态处理容易存在冲突、交互与层级管理的矛盾、日志收集上报易耦合。在这种现状下需要有一套更理想的解决方案来面向未来、最小化环境差异影响、兼容主流业务媒体资源，并且插件解耦与合理模块化，360前端团队产出了一套基于Video的可扩展的H5播放器解决方案<a href="http://chimee.org" target="_blank" rel="noopener">Chimee奇米</a>。</p>
<p>Chimee采用模块化分层设计，分别为Kernel层、dispatcher层、plugin层，其中Kernel为框架的底层用来解决各视频格式编码问题，dispatcher提供了一套事件处理方法，plugin用来为video自定义插件增加新的功能。可通过Chimee为业务做定制化开发，扩展Chimee插件增强业务功能。</p>
<h3 id="《Node-js微应用实践》"><a href="#《Node-js微应用实践》" class="headerlink" title="《Node.js微应用实践》"></a>《Node.js微应用实践》</h3><p>这个话题围绕前端、Node.js，聊到前端的微应用开发体系的实践，包含这三个部分：什么是微应用？为什么微应用？怎么构建微应用？</p>
<p>通常把产品分割为多个小模块，切细了开发。一个微应用完成一个业务功能，几个微应用组合得到新产品。那为什么要微应用呢？一个产品是一座冰山，一个系统用户不可见部分多得多，除了用户业务，还有各种管控、数据报表，出现前台业务耗费大量精力，后台系统力不从心的现象。数据场景具有众多的计算引擎、服务众多、服务访问量不高但很重要、需求众多等特点。</p>
<p>前端的通常状况是怎样的呢？基于Node.js作为开发工具，实现模块化、数据mock、打包编译、集成后端服务……开发、联调、集成，全套流程繁琐。碰到各种如小工具、ab测试、抓数据、文档服务等服务需要考虑到机器、访问、运维等问题。加上前端人员紧缺，提高前端的效率，从侧面解决人手短缺。如何改变这种困局呢？可以采用构建Node服务开发体系、分割产品、构建为应用运维体系措施提高效率，管理好产品经理这基本是很难的。然后介绍了各个措施的基本思路。构建Node层开发体系：web层框架一体，抽取前端的组件包，抽取Node.js层包。分割产品：信息架构，业务架构，多应用。构建微应用运维体系：构建，发布，运维，监控，扩容。</p>
<p>阿里云的实践体系分为微应用体系和进程管理之外的部分。微应用体系由app运行托管服务、app开发框架、运维和开发工具构成。进程管理之外的部分由路由托管，高可用、版本无缝切换，便捷配置、运维管理，面向进程vs面向应用构成。微应用在效率（开发、测试、重构、复用）、解放前端劳动力、节约资源成本上具有优势。微应用与微服务的关系，正像java与javascript，雷锋与雷锋塔的关系。与微服务对比，<strong>微应用关注应用接入和访问，微服务则关注服务接入和消费</strong>。</p>
<p>随着水下冰山在壮大，产品数据化研发需求，前后端分离的架构模式形成，产品的规模不断扩大，尝试使用微应用来开发产品。未来的AI由智能，数据和App（外设：接收端和执行端）构成。</p>
<h3 id="《天猫前端圆桌交流会》"><a href="#《天猫前端圆桌交流会》" class="headerlink" title="《天猫前端圆桌交流会》"></a>《天猫前端圆桌交流会》</h3><p>整个圆桌交流会原定时长2个小时，活动组织者邀请了参加D2其中的三十来人参加此次交流会，大家的热心和激情交流会持续了3个小时，切身投入到这个交流会比白天听他人演说收获更加丰厚、更有针对性。</p>
<p>交流会分为上下场，上半场由天猫前端委员会主题舒文给大家分享了天猫前端相关话题，围绕着“天猫前端组织的运作方式”、“全栈技术体系在天猫的应用场景”话题进行细说，下半场大家互相讨论各自遇到的问题以及感兴趣的话题。</p>
<p>上半场首先介绍了天猫在整个阿里体系的地位，天猫涉及到的业务。目前整个天猫前端团队150人左右，分成了4个组，各个组的侧重点不一样，目标是一致的。以双十一项目展开，在人力不足的情况下如何按期高质完成任务。除了单纯靠人力去完成外，还会借助自研的工具去高效完成。磨刀不误砍柴工，在业务场景下产出高效率的工具，才能更好的应对各种挑战和源源不断的业务需求。接着谈到全栈技术这个概念，虽然在工作岗位上有各种title，实际上面对一些棘手的问题，需要自己跳出这个圈以更广阔的视角去考虑问题，才有可能很好的解决问题。这个以页面性能优化为例，如何减少首屏的白屏时间尽快看到页面内容，圈内流行的雅虎32条性能优化黄金法则往往有限，需要结合后端一起去探讨这个问题。</p>
<p>下半场讨论大大小小的问题有许多，主要集中在技术视野和基于业务场景解决问题的能力培养、造轮子与资源利用之间的关系、前端委员会服务型理念、跨端跨团队学习沟通等话题。这里我提出了一个问题是“如何在跨团队间高效率完成工作任务？”。穆宸给了我一个比较满意的答案：“首先各团队要有相应的流程规范，然后项目需要把接口明确，各自做好mock数据单元测试，出现问题和风险及时主动推动”，平时在工作中也有按照这种思路去解决问题，但要完完全全落实到项目中往往不到位，各种非技术风险没来得及提前规避，在以后更需要高效率沟通去推动团队间协作。</p>
<p>最后以穆宸的一段话来结束这场火爆的圆桌交流会，“前端不只是开发页面，前端是用来解决实际问题，思考解决执行效果”。</p>
<h2 id="会后小结"><a href="#会后小结" class="headerlink" title="会后小结"></a>会后小结</h2><p>这次大会一共有21场主题演讲，限于个人精力和场地因素，只能优先选择上面这些话题，当然其他火爆的话题有《打造高可靠与高性能的React同构解决方案》、《Microbenchmark for JavaScript》、《前端复杂应用构建技术探索实》、《把前端监控做到极致》、《QQ空间HTTP2加速实践》等，这些会后结合PPT与视频慢慢消化，后期再补上文章小结。</p>
<p>还记得毕业那年14年兴致勃勃地参加主题为<a href="http://d2forum.alibaba-inc.com/#/past/d2-9" target="_blank" rel="noopener">《绽放》</a>的大会，Node.js在生产中的大规模应用，将前端工程化实践引向了新的高度；移动互联网的发展，前端玩法异彩纷呈；用户体验的增强，前端富应用已然成熟。15年大会主题<a href="http://d2forum.alibaba-inc.com/#/past/d2-10" target="_blank" rel="noopener">《融合》</a>，探索从web到端的实践，Node.js加速网页渲染效率，组件化实践提升开发效率。这次大会主题<a href="http://d2forum.alibaba-inc.com/#/index" target="_blank" rel="noopener">《匠心》</a>，前端话题显得更加多元化，开发涉及的端已经不止局限于PC端和移动端，最新的物联网领域前端开发在大会中首次露面，人工智能也有所提及；应用开发实践与体验优化占据了很大篇幅，日常工作中的重中之重；技术之外个人、团队成长的思考非常重要，如何保持在日常工作中得到快速成长是一门非常值得探索的学问。</p>
<p>日常工作中要善于去思考、去实践、去总结，收获会更多。</p>
]]></content>
      
        
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最好的前端手册 - 都在这里]]></title>
      <url>http://yoursite.com/2017/11/02/modern-frontend-hacking-cheatsheets/</url>
      <content type="html"><![CDATA[<p>几乎不可能用心记住所有的API。这就是什么时候需要用到手册！这里有我收集的最好的前端手册。</p>
<h3 id="JavaScript-ES2015特性"><a href="#JavaScript-ES2015特性" class="headerlink" title="JavaScript ES2015特性"></a><a href="https://devhints.io/es6" target="_blank" rel="noopener">JavaScript ES2015特性</a></h3><p><img src="/assets/201711/2017-11-02-es6.png" alt="JavaScript ES2015 Features"><br><a href="https://devhints.io/es6" target="_blank" rel="noopener">https://devhints.io/es6</a></p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><a href="http://overapi.com/javascript" target="_blank" rel="noopener">JavaScript</a></h3><p><img src="/assets/201711/2017-11-02-javascript.png" alt="JavaScript"><br><a href="http://overapi.com/javascript" target="_blank" rel="noopener">http://overapi.com/javascript</a></p>
<h3 id="JavaScript正则表达式"><a href="#JavaScript正则表达式" class="headerlink" title="JavaScript正则表达式"></a><a href="https://www.debuggex.com/cheatsheet/regex/javascript" target="_blank" rel="noopener">JavaScript正则表达式</a></h3><p><img src="/assets/201711/2017-11-02-javascript-exp.png" alt="JavaScript Regular expression"><br><a href="https://www.debuggex.com/cheatsheet/regex/javascript" target="_blank" rel="noopener">https://www.debuggex.com/cheatsheet/regex/javascript</a></p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a><a href="https://devhints.io/react" target="_blank" rel="noopener">React</a></h3><p><img src="/assets/201711/2017-11-02-react.png" alt="React"><br><a href="https://devhints.io/react" target="_blank" rel="noopener">https://devhints.io/react</a></p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a><a href="https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf" target="_blank" rel="noopener">Redux</a></h3><p><img src="/assets/201711/2017-11-02-redux.png" alt="Redux"><br><a href="https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf" target="_blank" rel="noopener">https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf</a></p>
<h3 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a><a href="https://vuejs-tips.github.io/cheatsheet/" target="_blank" rel="noopener">Vue.js</a></h3><p><img src="/assets/201711/2017-11-02-vuejs.png" alt="Vue.js"><br><a href="https://vuejs-tips.github.io/cheatsheet/" target="_blank" rel="noopener">https://vuejs-tips.github.io/cheatsheet/</a></p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a><a href="https://vuejs-tips.github.io/vuex-cheatsheet/" target="_blank" rel="noopener">Vuex</a></h3><p><img src="/assets/201711/2017-11-02-vuex.png" alt="Vuex"><br><a href="https://vuejs-tips.github.io/vuex-cheatsheet/" target="_blank" rel="noopener">https://vuejs-tips.github.io/vuex-cheatsheet/</a></p>
<h3 id="Angular-5"><a href="#Angular-5" class="headerlink" title="Angular 5"></a><a href="https://angular.io/guide/cheatsheet" target="_blank" rel="noopener">Angular 5</a></h3><p><img src="/assets/201711/2017-11-02-angular5.png" alt="Angular 5"><br><a href="https://angular.io/guide/cheatsheet" target="_blank" rel="noopener">https://angular.io/guide/cheatsheet</a></p>
<h3 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a><a href="https://yoksel.github.io/flex-cheatsheet/" target="_blank" rel="noopener">Flexbox</a></h3><p><img src="/assets/201711/2017-11-02-flexbox.png" alt="Flexbox"><br><a href="https://yoksel.github.io/flex-cheatsheet/" target="_blank" rel="noopener">https://yoksel.github.io/flex-cheatsheet/</a></p>
<h3 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a><a href="https://devhints.io/sass" target="_blank" rel="noopener">Sass</a></h3><p><img src="/assets/201711/2017-11-02-sass.png" alt="Sass"><br><a href="https://devhints.io/sass" target="_blank" rel="noopener">https://devhints.io/sass</a></p>
<h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a><a href="https://devhints.io/stylus" target="_blank" rel="noopener">Stylus</a></h3><p><img src="/assets/201711/2017-11-02-stylus.png" alt="Stylus"><br><a href="https://devhints.io/stylus" target="_blank" rel="noopener">https://devhints.io/stylus</a></p>
<h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a><a href="https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png" target="_blank" rel="noopener">GraphQL</a></h3><p><img src="/assets/201711/2017-11-02-graphql.png" alt="GraphQL"><br><a href="https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/sogko/graphql-shorthand-notation-cheat-sheet/master/graphql-shorthand-notation-cheat-sheet.png</a></p>
<p>遗漏了你最喜爱的手册？请在留言区让我知道！</p>
<p>如果你发现这篇文章有用，请给我一些掌声让更多的人看到。谢谢！</p>
<p><a href="https://medium.com/@wesharehoodies/easy-guide-for-webpack-2-0-from-scratch-fe508a3ce44e" target="_blank" rel="noopener">怎样从头开始搭建Webpack 2.0</a></p>
<p><a href="https://medium.com/@wesharehoodies/best-courses-to-learn-javascript-in-2017-fc3a254638cc" target="_blank" rel="noopener">2017学习JavaScript最好的课程</a></p>
<p><a href="https://medium.com/@wesharehoodies/bitcoin-ripple-ethereum-price-checker-with-react-native-redux-e9d076037092" target="_blank" rel="noopener">学习如何使用RN和Redux构建一个加密货币原生移动应用</a></p>
<p>当然，不要忘记更多地关注我！♥</p>
<p>文章翻译整理自 <a href="https://medium.freecodecamp.org/modern-frontend-hacking-cheatsheets-df9c2566c72a" target="_blank" rel="noopener">https://medium.freecodecamp.org/modern-frontend-hacking-cheatsheets-df9c2566c72a</a> 。</p>
]]></content>
      
        
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js 8和Node.js 9的新功能]]></title>
      <url>http://yoursite.com/2017/11/01/what-is-new-in-node-js-8-and-node-js-9/</url>
      <content type="html"><![CDATA[<p>Node.js 8现在处于<a href="https://www.infoworld.com/article/3001675/javascript/nodejss-release-cycle-hits-the-fast-lane.html" target="_blank" rel="noopener">长期支持（LTS）</a>发布状态，LTS旨在表示在企业部署中使用的稳定性水平。随着Node.js 8的这个版本处于稳定状态，Node.js 9的首次登场是异步资源跟踪，作为“当前”发行版。</p>
<h3 id="Node-js-8特性"><a href="#Node-js-8特性" class="headerlink" title="Node.js 8特性"></a>Node.js 8特性</h3><p><a href="https://www.infoworld.com/article/3233190/node-js/nodejs-tutorial-get-started-with-nodejs.html" target="_blank" rel="noopener">流行的服务器端JavaScript运行环境</a>的LTS发布，这个关注的是安全和稳定性。LTS发布版本活跃维护在18个月。<a href="https://www.infoworld.com/article/3199186/node-js/nodejs-8-brings-sanity-to-native-module-dependencies.html" target="_blank" rel="noopener">由Node.js基金会于5月下旬首次推出</a>的Node.js 8.x功能特点：</p>
<ul>
<li>Google V8 6.1 JavaScript引擎。</li>
<li>NPM 5.0.0客户端。</li>
<li>更好的性能——在典型的web应用程序上相比之前Node 6 LTS版本性能提升20%。</li>
</ul>
<p>两个其他功能——作为本地扩展（native-add-ons）的N-API和保持在实验阶段仍然受到代码变动的HTTP/2。Node.js基金会建议Node.js 6用户开始测试Node.js 8，Node.js 4用户升级到Node.js 8。</p>
<p>【了解Node？不过错过<a href="https://www.infoworld.com/article/3196070/node-js/10-javascript-concepts-nodejs-programmers-must-master.html#tk.ifw-infsb" target="_blank" rel="noopener">每个Node开发者必须掌握的10个JavaScript对象</a>. | <a href="https://www.infoworld.com/article/3204205/node-js/7-keys-to-structuring-your-nodejs-app.html#tk.ifw-infsb" target="_blank" rel="noopener">构建您的Node应用程序的7个关键点</a>. | 跟上程序热门话题使用Infowold的<a href="https://www.infoworld.com/newsletters/signup.html#tk.ifw-infsb" target="_blank" rel="noopener">应用开发报告通讯</a>.】</p>
<h3 id="Node-js-9新特性"><a href="#Node-js-9新特性" class="headerlink" title="Node.js 9新特性"></a>Node.js 9新特性</h3><p>对于Node.js 9，大多数改变主要在API的弃用或删除，并将代码库迁移到新的错误系统。迁移的目标是将唯一的代码与系统抛出的错误相关联，允许更改错误消息，而不会被视为破坏更改。Node.js 9其他特性包括：</p>
<ul>
<li>一个异步钩子模块，提供一个用于注册回调以跟踪应用程序中异步资源的API。此功能也出现在Node.js 8.x行中，在此阶段是实验性的。</li>
<li>Google V8 6.2 JavaScript引擎。</li>
<li>支持HTTP/2和N-API，它们可以在没有命令行标志的情况下使用，但仍然是实验性的。</li>
</ul>
<h3 id="哪里可以下载Node-js"><a href="#哪里可以下载Node-js" class="headerlink" title="哪里可以下载Node.js"></a>哪里可以下载Node.js</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js网站</a>上提供了最新的Node.js 8版本和9.x的下载URL。</p>
<p>文章整理翻译自<a href="https://www.infoworld.com/article/3235610/node-js/whats-new-in-nodejs-8-and-nodejs-9.html" target="_blank" rel="noopener">https://www.infoworld.com/article/3235610/node-js/whats-new-in-nodejs-8-and-nodejs-9.html</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack配置及热更新介绍]]></title>
      <url>http://yoursite.com/2017/10/21/webpack-configuration-and-hmr-intro/</url>
      <content type="html"><![CDATA[<h3 id="webpack介绍"><a href="#webpack介绍" class="headerlink" title="webpack介绍"></a>webpack介绍</h3><p><a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">webpack官网</a>是这么介绍的：</p>
<blockquote>
<p>webpack是用于现代JavaScript应用程序的模块打包器。当Webpack处理您的应用程序时，它递归地构建一个包含应用程序所需的每个模块的依赖关系图，然后将所有这些模块打包到少量的捆绑（通常只有一个），由浏览器加载。</p>
</blockquote>
<p>webpack打包是基于由一系列规则构成的配置文件生成模块文件，四个核心的配置项分别是入口文件（<a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">Entry</a>）、输出文件（<a href="https://webpack.js.org/concepts/output/" target="_blank" rel="noopener">Output</a>）、加载器（<a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="noopener">Loaders</a>）、插件（<a href="https://webpack.js.org/concepts/plugins/" target="_blank" rel="noopener">Plugins</a>）。</p>
<h3 id="webpack基本配置"><a href="#webpack基本配置" class="headerlink" title="webpack基本配置"></a>webpack基本配置</h3><p>webpack目前最新版本是3.8.1，分别有三个大版本1.x、2.x、3.x，从1.x升级到2.x有一些相关<a href="https://webpack.js.org/guides/migrating/" target="_blank" rel="noopener">配置规则变动</a>。下面以3.x版本展现一份基本的webpack配置文件内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./app/index'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/assets/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [<span class="string">'env'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">'.js'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">                warnings: <span class="literal">false</span>,</span><br><span class="line">                drop_console: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="webpack热更新介绍"><a href="#webpack热更新介绍" class="headerlink" title="webpack热更新介绍"></a>webpack热更新介绍</h3><p>什么是热更新呢？热更新（<a href="https://webpack.js.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">HMR</a>）在应用程序运行时交换，添加或删除模块，而不需要完全重新加载。采用热更新调试程序能够在页面模块更新后保留应用的状态、节省开发时间、更快地调整样式。</p>
<p>热更新可以用来替代LiveReload开发。它们之间的区别是热更新局部刷新，LiveReload页面整体刷新。</p>
<p>热更新是webpack重要的功能特性之一，它允许在运行时更新各种模块，而无需进行全面刷新。用于开发调试应用程序非常便利。</p>
<h3 id="webpack热更新配置"><a href="#webpack热更新配置" class="headerlink" title="webpack热更新配置"></a>webpack热更新配置</h3><p>这里有3种方式用来配置HMR项目，逐个地进行介绍。</p>
<h4 id="1、webpack-dev-server-CLI"><a href="#1、webpack-dev-server-CLI" class="headerlink" title="1、webpack-dev-server CLI"></a>1、webpack-dev-server CLI</h4><p>在命令行中运行webpack-dev-server命令，这种方式不需要改变webpack.config.js文件内容，它是最简单的。</p>
<p>可以访问这个<a href="https://github.com/yunxiange/wepack-hmr-demo/tree/master/webpack-dev-server-cli" target="_blank" rel="noopener">例子</a>，看看具体的配置内容和效果。</p>
<h4 id="2、webpack-dev-server-API"><a href="#2、webpack-dev-server-API" class="headerlink" title="2、webpack-dev-server API"></a>2、webpack-dev-server API</h4><p>从一个node.js脚本中运行WebpackDevServer。要求添加一些内容到你的webpack.config.js文件中。这个适合于采用grunt或者gulp任务流或者从你的node脚本中运行webpack。</p>
<p>具体的配置内容可查看<a href="https://github.com/yunxiange/wepack-hmr-demo/tree/master/webpack-dev-server-api" target="_blank" rel="noopener">这里</a>，有相应的示例效果。</p>
<h4 id="3、webpack-hot-middleware-w-express"><a href="#3、webpack-hot-middleware-w-express" class="headerlink" title="3、webpack-hot-middleware w/express"></a>3、webpack-hot-middleware w/express</h4><p><a href="https://github.com/glenjamin/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a>被用来运行一个webpack开发服务内置在express服务的HMR。这个用来集成到你的express服务。</p>
<p>详细的细节配置和运行效果，可以参照<a href="https://github.com/yunxiange/wepack-hmr-demo/tree/master/webpack-hot-middleware-express" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>接下来会针对webpack打包原理、热更新、性能优化进行深入的探讨。</p>
]]></content>
      
        
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你真的搞懂Promise了吗？]]></title>
      <url>http://yoursite.com/2017/10/14/are-you-rellay-understand-promise/</url>
      <content type="html"><![CDATA[<p>JavaScript开发者们，现在得承认：我们有一个关于promise的问题。</p>
<p>不，这不是promise自身问题。采用<a href="https://promisesaplus.com/" target="_blank" rel="noopener">A+ 规范</a>定义的Promise是非常酷的。</p>
<p>在过去一年中我遇到的最大问题，正如我看到许多程序员为PouchDB API和重promise API挣扎，是这个：</p>
<p>我们当中许多人在使用promise没有真正明白它。</p>
<p>如果你很难相信，想想我最近在twitter上发的<a href="https://twitter.com/nolanlawson/status/578948854411878400" target="_blank" rel="noopener">内容</a>：</p>
<p>问题：这四个promise的区别是什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<p>如果你知道这个答案，恭喜你是一个promise高手。你有权限停止阅读此博文。</p>
<p>相对其他99.99%的人你是在一个好公司。没有人回复我的推文可以解决这个问题。是的，尽管我写了这道谜题。</p>
<p>这个答案在文章的末尾，但是首先，我想开头解释下为什么promise如此诡异和为什么我们当中很多人像新手和专家一样绊倒在这个上。我将会提供我认为是一个奇特的视角，这是一个怪异的技巧，这使得明白promise。是的，看过这些后我真的确信这些不是非常难。</p>
<p>但首先，让我们挑战一些关于promise的常见问题。</p>
<h3 id="为什么会出现promise呢？"><a href="#为什么会出现promise呢？" class="headerlink" title="为什么会出现promise呢？"></a>为什么会出现promise呢？</h3><p>如果你阅读有关promise的文献，你可能经常会发现这个<a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf" target="_blank" rel="noopener">糟糕的金字塔</a>参考，一些逐渐出现到你的屏幕右下方的可怕回调代码。</p>
<p>promise确实解决了这个问题，但他不仅仅是缩进。正如在“<a href="http://youtu.be/hf1T_AONQJU" target="_blank" rel="noopener">回调地域救赎</a>”这个精彩的对话中所解释的那样，回调真正地问题是我们不能用return和throw语句。相反，我们程序的整个流程是这样：一个函数接着调用另一个函数。</p>
<p>事实上，回调做的某些事甚至非常的险恶：他夺走了我们在编程语言常见的程序堆栈。编写没有堆栈的代码非常像没有制动踏板的汽车：直到你需要它但它并不在时你会意识到多么的需要它。</p>
<p>promise的整个要点是当我们使用异步编程时将return、throw和堆栈用到了编程中。但是你必须知道如何正确使用promise以便利用它。</p>
<h3 id="新手错误"><a href="#新手错误" class="headerlink" title="新手错误"></a>新手错误</h3><p>有些人尝试解释promise成<a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" target="_blank" rel="noopener">一部漫画</a>，或者一个名词：“噢，它是你可以传递的代表异步值的东西”。</p>
<p>我没有发现那样的解释对我非常有帮助。对我来说，promise都是关于代码结构和流程的。所以我任务最好解决一些常见的错误，并展示如何去解决它们。“你现在是个新手、小孩，很快就会很专业”，在这个意思上我把这些问题称作新手错误。</p>
<p>扯下题外话，“promise”对不同的人意味着许多不同的东西，但是这篇文章的目的仅仅是在讨论官方规范，像现代浏览器中的<code>window.Promise</code>。但是不是所有的浏览器都有了<code>window.Promise</code>，这里会有一个好的兼容方法（polyfill），看看这个最小的兼容规范库<a href="https://github.com/calvinmetcalf/lie" target="_blank" rel="noopener">lie</a>。</p>
<h4 id="新手错误1：糟糕的promise金字塔"><a href="#新手错误1：糟糕的promise金字塔" class="headerlink" title="新手错误1：糟糕的promise金字塔"></a>新手错误1：糟糕的promise金字塔</h4><p>看看这个有很多基于promise API的PouchDB，我看到了很多不好的promise模式。最常见的坏习惯是这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(&#123;</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachments: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'Pulled doc with id '</span> + element.doc._id + <span class="string">' and added to local db.'</span>);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err.name == <span class="string">'conflict'</span>) &#123;</span><br><span class="line">                localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">                    localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params"> resp</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// et cetera...</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>是的，事实证明你在用promise好像它是回调，这很像使用电动砂光机在锉你的指甲，但是你可以做到。</p>
<p>如果你认为这类错误仅限于完全的新手，你会惊讶我是从BlackBerry官方的开发者博客上拿到的代码！旧友的回调习惯很难改。（对开发这说声抱歉，但这个例子是有启发性的。）</p>
<p>一种更好的方式是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个称之为组合promise，是promise超级强大的地方之一。每个函数仅在前一个函数运行完后利用其promise的返回结果调用，以此类推。</p>
<h4 id="新手错误2：WTF，我怎么在promise中使用forEach-？"><a href="#新手错误2：WTF，我怎么在promise中使用forEach-？" class="headerlink" title="新手错误2：WTF，我怎么在promise中使用forEach()？"></a>新手错误2：WTF，我怎么在promise中使用<code>forEach()</code>？</h4><p>这是大多数人对promise了解开始奔溃的地方。一旦他们达到他们熟悉的forEach()循环（或者for循环，或者while循环），他们就不知道怎么与promise结合起来一起工作。所以他们写出像下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除所有的docs</span></span><br><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">        db.remove(row.doc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 天真的认为现在所有的docs已经移除了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码有什么问题呢？这个问题是第一个函数实际上返回<code>undefined</code>，意味着第二个函数不会等待<code>db.remove()</code>在所有docs调用完。事实上，它不会等待任何操作，并且可以在任何数量的docs被删除时执行。</p>
<p>这是一个特别隐密的问题，因为你可能没有注意到有什么错误，假设PouchDB足够快地删除这些docs以便UI被更新。这个问题只能在奇怪的竞争条件下弹出，或者在某些浏览器中这样几乎不可能调试。</p>
<p>所有这些不是你寻找的结构forEach()/for/while的内容不必关注。你仅需要使用Promise.all()：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在所有的docs都已经移除了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里发生了什么？基础上Promise.all()把一系列的promise作为输入，然后只有当其他promise中的每一个都解决时给出另一个已解决的promise。它与for循环异步等效。</p>
<p>Promise.all()将一个结果数组传递给下一个函数，这非常有用，例如如果您尝试从PouchDB获取多个东西。如果其所有子promise中的任何一个被拒绝，all()承诺也被拒绝，这更为有用。</p>
<h4 id="新手错误3：忘记添加-catch"><a href="#新手错误3：忘记添加-catch" class="headerlink" title="新手错误3：忘记添加.catch()"></a>新手错误3：忘记添加<code>.catch()</code></h4><p>这是另一个常见错误。很自信他们的promise永远不会抛出错误，许多开发人员忘记在他们的代码中添加一个.catch()。不幸的是，这意味着任何抛出的错误将被吞下，你甚至不会在控制台中看到它们。这可能是一个真正的痛苦调试。</p>
<p>为了避免这种讨厌的情况，我已经习惯了将以下代码添加到我的promise链中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>));</span><br></pre></td></tr></table></figure></p>
<p>即使你从来没预料过错误，添加一个catch()一直是谨慎的。如果你的假设是错误的，这将使你的生活更轻松。</p>
<h4 id="新手错误4：使用deferred"><a href="#新手错误4：使用deferred" class="headerlink" title="新手错误4：使用deferred"></a>新手错误4：使用<code>deferred</code></h4><p>这是我一直我看到的错误，我不愿在这里重复一遍，因为担心，像Beetlejuice，只是调用它的名字将出现更多的例子。</p>
<p>简而言之，promise有悠久的历史，并且JavaScript社区花了很长时间才能让他们正确。在早期，jQuery和Angular正在使用这种“延迟”模式，现在已经被ES6 Promise规范所取代，由实现这种规范“好的”库如Q，When，RSVP，Bluebird，Lie等等。</p>
<p>所以如果你在你的代码中写这个词（我不会再重复一遍，第三次了），你做错了。以下是如何避免这种情况。</p>
<p>首先，大多数promise库都为您提供了从第三方库中“引进”了promise。例如，Angular的$ q模块允许您使用$q.when()来包装非$q promise。所以Angular用户可以这样包装PouchDB promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then( <span class="comment">/* ... */</span>);  <span class="comment">// &lt;-- 这是你需要的所有代码</span></span><br></pre></td></tr></table></figure></p>
<p>另一种方法是使用<a href="https://blog.domenic.me/the-revealing-constructor-pattern/" target="_blank" rel="noopener">揭示构造器模式（revealing constructor pattern）</a>，对包装非promise api有用。比如包装一个像Node的fs.readFile()基于回调的API，你只需要这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="comment">/* .... */</span>);</span><br></pre></td></tr></table></figure></p>
<p>完成！我们已经击败了可怕的def … Aha，抓住了自己。:)</p>
<blockquote>
<p>更多的关于为什么这是一个反模式，请查看<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">Bluebird维基页面关于promise反模式</a>。</p>
</blockquote>
<h4 id="新手错误5：不使用return的副作用"><a href="#新手错误5：不使用return的副作用" class="headerlink" title="新手错误5：不使用return的副作用"></a>新手错误5：不使用<code>return</code>的副作用</h4><p>这段代码出现什么错误呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    someOtherPromise();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 哎，我希望someOtherPromise（）已经解决了！</span></span><br><span class="line">    <span class="comment">// Spoiler警报：没有。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>好的，这是一个很好的一点，谈论你需要了解promise的一切。真的，这是一个奇怪的伎俩，一旦你明白了，就会阻止我所说的所有错误。你准备好了吗？</p>
<p>正如我之前所说，promise的魔力是他们给我们带回了我们宝贵的return和throw。但这实际上是什么样的呢？</p>
<p>每个promise给你一个then()方法（或者catch()，这只是then(null, …)的语法糖）。这里我们在一个then()函数里面：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我在一个then函数里面</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这儿我们该怎么办？有三件事情：</p>
<p>1、return另一个promise<br>2、return一个同步值（或者undefined）<br>3、throw一个同步错误</p>
<p>就这些。一旦了解这个特招，你就明白了promise。那么让我们一次一个个地去看每个点。</p>
<h5 id="1、return另一个promise"><a href="#1、return另一个promise" class="headerlink" title="1、return另一个promise"></a>1、return另一个promise</h5><p>这是你在promise文献中看到的常见模式，如上面的“组合promise”示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获取了一个用户帐户！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意我return了第二个promise——return至关重要。如果我没有返回，那么getUserAccountById（）实际上会是一个副作用，下一个函数将会接收到undefined而不是userAccount。</p>
<h5 id="2、return一个同步值（或者undefined）"><a href="#2、return一个同步值（或者undefined）" class="headerlink" title="2、return一个同步值（或者undefined）"></a>2、return一个同步值（或者undefined）</h5><p>返回undefined通常是一个错误，但是返回一个同步值实际上是将同步代码转换为promise代码的好方法。例如，假设我们有一个用户的内存缓存。我们可以做的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获取了一个用户帐户！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>不是很棒吗？第二个函数不关心userAccount是同步还是异步地获取，第一个函数可以自由返回同步或异步值。</p>
<p>不幸的是，不方便的事实是JavaScript中的非返回函数在技术上返回undefined，这意味着当您意图返回某些东西时，很容易意外引入副作用。</p>
<p>因此，我将它作为个人习惯，总是从then()函数return或throw。我建议你做同样的事情。</p>
<h5 id="3、throw一个同步错误"><a href="#3、throw一个同步错误" class="headerlink" title="3、throw一个同步错误"></a>3、throw一个同步错误</h5><p>说到throw，这是promise可以得到更棒的地方。假设我们要抛出同步错误，以防用户注销。这很容易：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">//抛出一个同步错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">        <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// 返回一个同步值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// 返回一个promise！</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 我获得一个用户帐户！</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 嘘，出现错误！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果用户注销，我们的catch()将收到同步错误，如果有任何promise被拒绝，它将收到异步错误。同样，该函数不关心其获取的错误是同步还是异步。</p>
<p>这是特别有用的，因为它可以帮助识别开发过程中的编码错误。例如，如果在then()函数内的任何一点，我们做一个JSON.parse()，如果JSON无效，它可能会引发同步错误。使用回调，这个错误会被吞噬，但是有了承诺，我们可以在我们的catch()函数中简单的处理它。</p>
<h3 id="高级错误"><a href="#高级错误" class="headerlink" title="高级错误"></a>高级错误</h3><p>好吧，现在你已经学会了让promise变得简单的一个技巧，让我们来谈谈边缘案例。当然，总是有边缘的情况。</p>
<p>我把这些错误归类为“高级”，因为我只看过他们已经很熟悉promise的程序员了。但是，如果我们想要解决我在这篇文章开头提出的难题，我们将需要讨论它们。</p>
<h4 id="高级错误1：不知道Promise-resolve"><a href="#高级错误1：不知道Promise-resolve" class="headerlink" title="高级错误1：不知道Promise.resolve()"></a>高级错误1：不知道<code>Promise.resolve()</code></h4><p>如上所示，promise对于将同步代码作为异步代码来说非常有用。但是，如果您发现自己键入很多：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure></p>
<p>这对于捕获任何同步错误也是非常有用的。这是非常有用的，我已经习惯了开始几乎所有的promise-returning的API方法，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        doSomethingThatMayThrow();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">    &#125;).then(<span class="comment">/* ... */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要记住：对于在某处几乎不可能调试的吞咽错误，任何可能同步throw的代码是一个很好的候选对象。但是如果你把所有内容都包含在Promise.resolve()中，那么你可以随时确定catch()。</p>
<p>同样，有一个Promise.reject()可以用来返回一个立即被拒绝的承诺：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="高级错误2：catch-与then-null-并不完全一样"><a href="#高级错误2：catch-与then-null-并不完全一样" class="headerlink" title="高级错误2：catch()与then(null, ...)并不完全一样"></a>高级错误2：<code>catch()</code>与<code>then(null, ...)</code>并不完全一样</h4><p>我上面说的catch()只是语法糖。所以这两个片段是等价的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是，这并不意味着以下两个片段是等效的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果您想知道为什么它们不相等，请考虑如果第一个函数抛出错误会发生什么：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 捕捉到错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 没有捕获到错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>事实证明，当您使用then(resolveHandler, rejectHandler)格式时，如果resolveHandler本身抛出，rejectHandler将不会实际捕获错误。</p>
<p>因此，我已经习惯了不要再使用then()第二个参数，并且总是喜欢catch()。例外情况是当我正在编写异步<a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a>测试时，我可以在其中写一个测试来确保抛出错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I except an error!'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        should.exist(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>说到这一点，<a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a>和<a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a>是一个可爱的组合来测试承诺的API。 <a href="https://github.com/pouchdb/plugin-seed" target="_blank" rel="noopener">pouchdb-plugin-seed</a>项目有一些可以让您开始的<a href="https://github.com/pouchdb/plugin-seed/blob/master/test/test.js" target="_blank" rel="noopener">示例测试</a>。</p>
<h4 id="高级错误3：promise和promise工厂"><a href="#高级错误3：promise和promise工厂" class="headerlink" title="高级错误3：promise和promise工厂"></a>高级错误3：promise和promise工厂</h4><p>假设你想按顺序执行一系列的promise。那就是你想要的是Promise.all()，但是并不执行这些承诺。</p>
<p>你可能会天真地写这样的东西：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resut = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">        result = result.then(promise);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不幸的是，这不符合你的意图。您传递给executeSequentially()的promise仍将并行执行。</p>
<p>发生这种情况的原因是，你不想在一系列promise上操作。根据promise规范，一旦promise创建，它将开始执行。所以你真正想要的是一系列的promise工厂：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">        result = result.then(promiseFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我知道你在想什么：“这个Java程序员究竟是谁，他为什么在谈论工厂？”一个promise工厂很简单，但它只是一个返回promise的功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么这样工作？起作用的是因为一个promise的工厂直到被要求才产生promise。它的工作方式与then的功能相同 - 事实上，它是一回事！</p>
<p>如果你看看上面的executeSequentially()函数，然后想象myPromiseFactory被替换为result.then(…)，那么希望一个灯泡会点醒你的大脑。在那一刻，你将会实现有promise的启示。</p>
<h4 id="高级错误4：好的，如果我想要两个promise的结果呢？"><a href="#高级错误4：好的，如果我想要两个promise的结果呢？" class="headerlink" title="高级错误4：好的，如果我想要两个promise的结果呢？"></a>高级错误4：好的，如果我想要两个promise的结果呢？</h4><p>通常情况下，一个promise将取决于另一个promise，但我们希望这两个promise的输出。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 危险，我也需要“user”对象！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>想要成为好的JavaScript开发人员，并避免使用金字塔，我们可能只将用户对象存储在更高作用域的变量中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    user = result;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 好了，我同时拥有“user”和“userAccount”</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个能够运行，但我个人觉得有点凑巧。我推荐的策略：放开你的先入为主并拥抱金字塔：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUerAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 好了，我同时拥有“user”和“userAccount”</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>…至少，暂时的如果缩进成为一个问题，那么您可以做JavaScript开发人员自古以来一直在做的工作，并将该功能提取到一个命名的函数中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">    .then(onGetUser)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在这一点上，doSomething()完成，我们回到0缩进</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>随着您的promise代码开始变得越来越复杂，您可能会发现自己将越来越多的函数提取到命名函数中。我发现这会导致非常美观的代码，可能看起来像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn()</span><br><span class="line">    .then(putYourRightFootOut)</span><br><span class="line">    .then(putYourRightFootIn)</span><br><span class="line">    .then(shakeItAllAbout);</span><br></pre></td></tr></table></figure></p>
<p>这就是promise的一切。</p>
<h4 id="高级错误5：promise破坏"><a href="#高级错误5：promise破坏" class="headerlink" title="高级错误5：promise破坏"></a>高级错误5：promise破坏</h4><p>最后，当我介绍上面的promise难题时，这是我提到的错误。这是一个非常深奥的用例，它可能永远不会出现在你的代码中，但它确实让我感到惊讶。</p>
<p>你认为这个代码打印出来什么？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果你认为打印出来bar，你是错误的。它实际上打印出foo！</p>
<p>发生这种情况的原因是因为当你传递then()一个非函数（如承诺）时，它实际上将它解释为then(null)，这导致先前的promise的结果通过。你可以自己测试一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>添加尽可能多的then(null)；它仍然会打印foo。</p>
<p>这实际上回到了我说promise vs promise工厂的前一点。简而言之，您可以直接将promise直接传递给then()方法，但不会执行您的想法。那么then()应该是一个函数，所以很可能你打算做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这将像我们预期的那样打印bar。</p>
<p>所以只是提醒自己：总是传递一个函数到then()！</p>
<h3 id="解决谜题"><a href="#解决谜题" class="headerlink" title="解决谜题"></a>解决谜题</h3><p>现在我们已经学到了所有有关promise（或接近它）的知识，我们应该能够解决我最初在这篇文章开始时提出的难题。</p>
<p>这是每道题的答案，以图形格式，所以你可以更好地可视化它：</p>
<h4 id="谜题1"><a href="#谜题1" class="headerlink" title="谜题1"></a>谜题1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题2"><a href="#谜题2" class="headerlink" title="谜题2"></a>谜题2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                  finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题3"><a href="#谜题3" class="headerlink" title="谜题3"></a>谜题3</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse())</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">|---------------------------------|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure></p>
<h4 id="谜题4"><a href="#谜题4" class="headerlink" title="谜题4"></a>谜题4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(doSomethingElse)</span><br><span class="line">  .then(finalHandler);</span><br></pre></td></tr></table></figure>
<p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure></p>
<p>如果这些答案仍然没有弄明白，那么我建议您重新阅读这篇文章，或者定义doSomething()和doSomethingElse()方法，并在浏览器中自行尝试。</p>
<blockquote>
<p>说明：对于这些例子，我假设doSomething()和doSomethingElse()都返回promise，并且这些promise代表了JavaScript事件循环之外的事情（例如IndexedDB，network，setTimeout），这就是为什么它们在适当时显示为并发。这是一个<a href="http://jsbin.com/tuqukakawo/1/edit?js,console,output" target="_blank" rel="noopener">JSBin</a>来演示。</p>
</blockquote>
<p>对于更高级的promise使用，请查看我的<a href="https://gist.github.com/nolanlawson/6ce81186421d2fa109a4" target="_blank" rel="noopener">promise提示表</a>。</p>
<h3 id="关于promise的后话"><a href="#关于promise的后话" class="headerlink" title="关于promise的后话"></a>关于promise的后话</h3><p>promise是伟大的。如果您仍然使用回调，我强烈建议您切换到承诺。您的代码将变得更小，更优雅，更容易理解。</p>
<p>如果你不相信我，这里就是证明：<a href="https://t.co/hRyc6ENYGC" target="_blank" rel="noopener">PouchDB的map/reduce模块的重构</a>使用promise替代callback。结果：290次插入，555次删除。</p>
<p>顺便说一下，写那个讨厌的回调代码的人是…我！所以这是作为我的promise的原始力量的第一课，我感谢其他PouchDB贡献者一路上教导我。</p>
<p>话虽如此，promise并不完美。这是真的，他们比回调更好，但这是一个很好的说，一个打在肠道比一个踢在牙齿更好。当然，一个比另一个更好，但是如果你有一个选择，你可能会避免它们。</p>
<p>虽然优于回调，promise仍然难以理解和容易出错，这表现在我觉得不得不写这篇博文。新手和专家都会经常混淆这些东西，真的，这不是他们的错。问题在于promise虽然与我们在同步代码中使用的模式类似，但却是一个合适的替代品，但不完全相同。</p>
<p>实际上，你不应该学习一堆神秘的规则和新的API来做这些事情，在同步的世界里，你可以很好地完成熟悉的模式，如return，catch，throw和for-loop。不应该有两个并行的系统，你必须始终保持串行。</p>
<h3 id="期待async-await"><a href="#期待async-await" class="headerlink" title="期待async/await"></a>期待async/await</h3><p>这就是我在<a href="http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="noopener">“用ES7驯服异步野兽”</a>中所做的一点，我在那里探索了ES7 async/await关键字，以及如何将承诺更深入地融入到语言中。 ES7可以让我们使用真正的try / catch / return关键字，就像我们在CS 101中学到一样，而不必编写伪同步代码（使用一种类似于catch的假捕获()方法，但不是真的）。</p>
<p>这是JavaScript作为一种语言的巨大福音。因为最后，只要在我们犯了错误时我们的工具不会告诉我们，这些承诺的反模式仍然会继续发生。</p>
<p>以JavaScript的历史为例，我认为说<a href="http://jslint.com/" target="_blank" rel="noopener">JSLint</a>和<a href="http://jshint.com/" target="_blank" rel="noopener">JSHint</a>比<a href="http://amzn.com/0596517742" target="_blank" rel="noopener">《JavaScript: The Good Parts》</a>更好的服务于社区，即使它们有效地包含了相同的信息。被告知你刚刚在你的代码中所犯的错误，而不是阅读一本你试图了解别人的错误的书。</p>
<p>ES7 aynsc/await的美妙之处在于，在大多数情况下，您的错误会将自己显示为语法/编译器错误，而不是微妙的运行时错误。在此之前，掌握了ES5和ES6中的promise能力，以及如何正确使用它们。</p>
<p>所以，当我认识到，像《JavaScript：The Good Parts》，这个博客文章只能有一个有限的影响，当你看到他们犯同样的错误希望你可以指出。因为我们还有太多人只需要承认：“我有promise的问题！”</p>
<blockquote>
<p>更新：有人指出，Bluebird 3.0将打印出可以防止我在这篇文章中发现的许多错误的警告。所以使用Bluebird是另一个很好的选择，而我们期待ES7！<br>现在ES 2017已经发布了规范，实现了async/await特性，激动人心！</p>
</blockquote>
<p>本篇文章翻译自 <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Web开发演化]]></title>
      <url>http://yoursite.com/2017/10/07/the-revolution-of-web-development-2016/</url>
      <content type="html"><![CDATA[<p>随着时间推移，web开发带来了戏剧性变化，现代化web开发包含了一系列的工具、方法和概念。这些工具可能很复杂，但可以创建以前不可能实现的具有更快的开发速度和更好的可维护性的强大的应用程序。</p>
<h2 id="Web开发简史"><a href="#Web开发简史" class="headerlink" title="Web开发简史"></a>Web开发简史</h2><h3 id="Web-1-0（1991-2001）"><a href="#Web-1-0（1991-2001）" class="headerlink" title="Web 1.0（1991-2001）"></a>Web 1.0（1991-2001）</h3><p>这段时期典型的站点是由静态的html页面构成，在全球的城市或大学页面上托管，采用FrontPage、DreamWeaver或Notepad写成。</p>
<p><img src="/assets/201710/2017-10-11-web1.0.png" alt="2017-10-11-web1.0"></p>
<h4 id="Web-1-0：技术"><a href="#Web-1-0：技术" class="headerlink" title="Web 1.0：技术"></a>Web 1.0：技术</h4><p>CGI-BIN和Perl<br>PHP和ASP</p>
<h4 id="Web-1-0：交互"><a href="#Web-1-0：交互" class="headerlink" title="Web 1.0：交互"></a>Web 1.0：交互</h4><p>HTML表单<br>Java applets<br>ActiveX controls<br>动态HTML（DHTML）</p>
<p><img src="/assets/201710/2017-10-11-web1.0-interactivity.png" alt="2017-10-11-web1.0-interactivity"></p>
<h4 id="Web-1-0：浏览器"><a href="#Web-1-0：浏览器" class="headerlink" title="Web 1.0：浏览器"></a>Web 1.0：浏览器</h4><p>Mosaic<br>Netscape<br>Internet Explorer</p>
<p><img src="/assets/201710/2017-10-11-web1.0-browsers.png" alt="2017-10-11-web1.0-browsers"></p>
<h4 id="Web-1-0：代码共享"><a href="#Web-1-0：代码共享" class="headerlink" title="Web 1.0：代码共享"></a>Web 1.0：代码共享</h4><p>脚本网站</p>
<p><img src="/assets/201710/2017-10-11-web1.0-code-sharing.png" alt="2017-10-11-web1.0-code-sharing"></p>
<h4 id="Web-1-0：里程碑"><a href="#Web-1-0：里程碑" class="headerlink" title="Web 1.0：里程碑"></a>Web 1.0：里程碑</h4><p>HTML、CSS和JavaScript发明<br>Java和Flash发明<br>采用img和iframe标签实现的多媒体<br>blink和marquee标签</p>
<h3 id="Web-2-0（2001-2010）"><a href="#Web-2-0（2001-2010）" class="headerlink" title="Web 2.0（2001-2010）"></a>Web 2.0（2001-2010）</h3><p>这个阶段的网站采用服务端渲染页面，MySQL数据库，运行在J2EE、Rails或者PHP上。</p>
<p><img src="/assets/201710/2017-10-11-web2.0.png" alt="2017-10-11-web2.0"></p>
<h4 id="Web-2-0：服务端技术"><a href="#Web-2-0：服务端技术" class="headerlink" title="Web 2.0：服务端技术"></a>Web 2.0：服务端技术</h4><p>J2EE、ASP.NET、Rails、Django、LAMP<br>单独架构</p>
<p><img src="/assets/201710/2017-10-11-web2.0-server-technologies.png" alt="2017-10-11-web2.0-server-technologies"></p>
<h4 id="Web-2-0：客户端技术"><a href="#Web-2-0：客户端技术" class="headerlink" title="Web 2.0：客户端技术"></a>Web 2.0：客户端技术</h4><p>Ajax（Asynchronous JavaScript And XML）<br>MOOTOOLS（A COMPACT JAVASCRIPT FRAMEWORK）<br>prototype<br>jQuery</p>
<p><img src="/assets/201710/2017-10-11-web2.0-client-technologies.png" alt="2017-10-11-web2.0-client-technologies"></p>
<h4 id="Web-2-0：浏览器"><a href="#Web-2-0：浏览器" class="headerlink" title="Web 2.0：浏览器"></a>Web 2.0：浏览器</h4><p>IE6<br>Mozilla（Firefox）<br>IE6 → IE8<br>ACID测试</p>
<p><img src="/assets/201710/2017-10-11-web2.0-browsers.png" alt="2017-10-11-web2.0-browsers"></p>
<h4 id="Web-2-0：富应用"><a href="#Web-2-0：富应用" class="headerlink" title="Web 2.0：富应用"></a>Web 2.0：富应用</h4><p>插件：Flash、Silverlight<br>Web组件框架：GWT、EXT、YUI</p>
<p><img src="/assets/201710/2017-10-11-web2.0-rich-interactive-applications.png" alt="2017-10-11-web2.0-rich-interactive-applications"></p>
<h4 id="Web-2-0：代码共享"><a href="#Web-2-0：代码共享" class="headerlink" title="Web 2.0：代码共享"></a>Web 2.0：代码共享</h4><p>Sourceforge<br>Google Code</p>
<p><img src="/assets/201710/2017-10-11-web2.0-code-sharing.png" alt="2017-10-11-web2.0-code-sharing"></p>
<h4 id="Web-2-0：数据传输"><a href="#Web-2-0：数据传输" class="headerlink" title="Web 2.0：数据传输"></a>Web 2.0：数据传输</h4><p>XML<br>SOAP/WS-*</p>
<p><img src="/assets/201710/2017-10-11-web2.0-data-transfer.gif" alt="2017-10-11-web2.0-data-transfer"></p>
<h4 id="Web-2-0：里程碑"><a href="#Web-2-0：里程碑" class="headerlink" title="Web 2.0：里程碑"></a>Web 2.0：里程碑</h4><p>AJAX, JSON<br>Mobile<br>Stack Overflow!</p>
<h3 id="现代时期（2010-至今）"><a href="#现代时期（2010-至今）" class="headerlink" title="现代时期（2010-至今）"></a>现代时期（2010-至今）</h3><p>这个时期网站典型的特点是客户端JS、JSON API、跑在云服务上基于Node构建的微服务、NoSQL数据库。</p>
<p><img src="/assets/201710/2017-10-11-modern-era.png" alt="2017-10-11-modern-era"></p>
<h4 id="现代时期：服务端技术"><a href="#现代时期：服务端技术" class="headerlink" title="现代时期：服务端技术"></a>现代时期：服务端技术</h4><p>express+node+mongodb<br>Play Framework（build web applications with Java &amp; Scala）</p>
<p>amazon web services<br>HEROKU<br>Microsoft Azure</p>
<p>Flask<br>Dropwizard</p>
<p><img src="/assets/201710/2017-10-11-modern-era-server-technologies.png" alt="2017-10-11-modern-era-server-technologies"></p>
<h4 id="现代时期：客户端技术"><a href="#现代时期：客户端技术" class="headerlink" title="现代时期：客户端技术"></a>现代时期：客户端技术</h4><p>BACKBONE.JS、ANGULARJS<br>ember.js、React<br>Bootstrap、Foundation、Semantic UI</p>
<p><img src="/assets/201710/2017-10-11-modern-era-client-technologies.png" alt="2017-10-11-modern-era-client-technologies"></p>
<h4 id="现代时期：浏览器"><a href="#现代时期：浏览器" class="headerlink" title="现代时期：浏览器"></a>现代时期：浏览器</h4><p>Chrome、IE → Edge、Firefox、Safari<br>长青版本（Can I use）</p>
<p><img src="/assets/201710/2017-10-11-modern-era-browsers.png" alt="2017-10-11-modern-era-browsers"></p>
<h4 id="现代时期：HTML5"><a href="#现代时期：HTML5" class="headerlink" title="现代时期：HTML5"></a>现代时期：HTML5</h4><p>Web Workers<br>HTML(5)、CSS(3)、Websockets、WebGL、FLEX</p>
<p><img src="/assets/201710/2017-10-11-modern-era-html5.png" alt="2017-10-11-modern-era-html5"></p>
<h4 id="现代时期：代码共享"><a href="#现代时期：代码共享" class="headerlink" title="现代时期：代码共享"></a>现代时期：代码共享</h4><p>github<br>npm</p>
<p><img src="/assets/201710/2017-10-11-modern-era-code-sharing.png" alt="2017-10-11-modern-era-code-sharing"></p>
<h4 id="现代时期：数据传输"><a href="#现代时期：数据传输" class="headerlink" title="现代时期：数据传输"></a>现代时期：数据传输</h4><p>JSON over HTTP</p>
<p><img src="/assets/201710/2017-10-11-modern-era-data-transfer.png" alt="2017-10-11-modern-era-data-transfer"></p>
<h4 id="现代时期：里程碑"><a href="#现代时期：里程碑" class="headerlink" title="现代时期：里程碑"></a>现代时期：里程碑</h4><p>Node.js<br>插件之死（Flash）</p>
<p><img src="/assets/201710/2017-10-11-modern-era-milestones.png" alt="2017-10-11-modern-era-milestones"></p>
<h2 id="Web技术时间线"><a href="#Web技术时间线" class="headerlink" title="Web技术时间线"></a>Web技术时间线</h2><p><img src="/assets/201710/2017-10-11-timeline-of-web-technologies.png" alt="Timeline of Web Technologies"></p>
<h2 id="JavaScript简史"><a href="#JavaScript简史" class="headerlink" title="JavaScript简史"></a>JavaScript简史</h2><ul>
<li>1995：网景公司Brendan Eich发明JavaScript语言</li>
<li>1999：ES3规范敲定；微软发明XMLHttpRequest</li>
<li>2001：Douglas Crockford推广JSON格式</li>
<li>2005：推广“AJAX”术语</li>
<li>2006：John Resig发明jQuery</li>
<li>2008：Douglas Crockford出版《JavaScript：the Good Parts》</li>
<li>2009：ES5规范敲定；Ryan Dahl发明Node.js</li>
<li>2010：Underscore.js、Backbone.js、由Jeremy Ashkenas发明CoffeeScript</li>
<li>2015：ES6规范敲定</li>
</ul>
<p><img src="/assets/201710/2017-10-11-ecmascript-releases.png" alt="2017-10-11-ecmascript-releases"></p>
<h2 id="现代Web开发景观"><a href="#现代Web开发景观" class="headerlink" title="现代Web开发景观"></a>现代Web开发景观</h2><h3 id="现代Web开发：这是什么？"><a href="#现代Web开发：这是什么？" class="headerlink" title="现代Web开发：这是什么？"></a>现代Web开发：这是什么？</h3><p><img src="/assets/201710/2017-10-11-modern-web-devlopment-wat-is-this.png" alt="2017-10-11-modern-web-devlopment-wat-is-this"></p>
<h3 id="JavaScript-Client挑战"><a href="#JavaScript-Client挑战" class="headerlink" title="JavaScript/Client挑战"></a>JavaScript/Client挑战</h3><blockquote>
<p>JavaScript设计的目的是当你放在页面上能让它跳动起来。脚本通常是一行。我们认为10行脚本是非常正常的，100行脚本是巨大的，1000行脚本闻所未闻。这门语言最初绝不是用来搞大型的编程，我们的实现方案、性能指标都是未知的。<br>前微软IE/JS开发者Eric Lippert<br><a href="http://programmers.stackexchange.com/a/221658/214387" target="_blank" rel="noopener">http://programmers.stackexchange.com/a/221658/214387</a></p>
</blockquote>
<ul>
<li>无内置的模块定义系统</li>
<li>无封装</li>
<li>与大多数语言不同的采用原型继承系统</li>
<li>无静态类型的声明或编译</li>
<li>动态修改的对象和数据</li>
<li>最小标准库</li>
<li>浏览器功能变化</li>
<li>文档布局模型应用在应用程序布局</li>
</ul>
<h3 id="JavaScript-Client开发目标"><a href="#JavaScript-Client开发目标" class="headerlink" title="JavaScript/Client开发目标"></a>JavaScript/Client开发目标</h3><ul>
<li>网络字节最小化</li>
<li>处理浏览器兼容性问题</li>
<li>填补JS标准库与语言规范间的空白</li>
<li>在应用程序之间重用和共享代码</li>
<li>构建越来越复杂的大型浏览器端应用程序</li>
</ul>
<blockquote>
<p>人们认为写客户端应用程序很容易，这就是人们出现混乱、没有组合、成千上万条意大利面条式丑陋代码境况的原因。在浏览器中编写应用程序应该与建立数据或者创建一个服务层一样受尊重。对前端代码缺乏尊重是前端项目出现糟糕代码的最大原因。<br>是的，你将需要使用工具webpack、jspm、browserify配合babel、typescript以及postcss、less、scss来开发。就像你为桌面应用程序编写代码一样，你可能至少需要安装一个IDE并且可能需要几个库。···得到一个Java应用程序需要些什么呢？Maven，一些构建工具，一些其他的工具，理解组件/类的层级？使用任何新的工具都不容易。<br><a href="https://news.ycombinator.com/item?id=11782234" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=11782234</a></p>
</blockquote>
<h3 id="现代工具：语言-编译器"><a href="#现代工具：语言-编译器" class="headerlink" title="现代工具：语言/编译器"></a>现代工具：语言/编译器</h3><ul>
<li>ES6/ES2015(+)<ul>
<li>当前版本语言规范</li>
<li>浏览器和JS引擎跟进实现</li>
<li>分阶段发展未来提议的语言特性</li>
</ul>
</li>
<li>Babel<ul>
<li>基于插件的JavaScript混合编译器</li>
<li>广泛用于编译ES6等语言功能成向后兼容的ES5</li>
</ul>
</li>
<li>TypeScript<ul>
<li>来自微软的静态类型ES6超集</li>
</ul>
</li>
<li>SASS/LESS<ul>
<li>具有变量、控制流程、选择器嵌套能编译成css的语言</li>
</ul>
</li>
</ul>
<h3 id="现代工具：代码共享"><a href="#现代工具：代码共享" class="headerlink" title="现代工具：代码共享"></a>现代工具：代码共享</h3><ul>
<li>模块格式<ul>
<li>AMD（异步模块定义）：用于异步浏览器加载</li>
<li>CommonJS：用于Node从文件系统中加载内容</li>
<li>ES6：用于静态分析用于构建优化</li>
</ul>
</li>
<li>包装和执行<ul>
<li>Node.js<ul>
<li>浏览器外的JavaScript运行环境</li>
<li>V8引擎，来自Chrome，添加了一些额外的系统交互交口（文件系统、套接字…）</li>
<li>所有的服务端/构建工具都用JavaScript编写</li>
</ul>
</li>
<li>NPM<ul>
<li>采用Node的包管理器</li>
<li>创建、安装、管理JavaScript包和依赖</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="现代工具：构建工具"><a href="#现代工具：构建工具" class="headerlink" title="现代工具：构建工具"></a>现代工具：构建工具</h3><ul>
<li>构建步骤<ul>
<li>编译：将ES6/TypeScript转成兼容性好的ES5</li>
<li>合并：把多个文件合成一个输出文件</li>
<li>压缩：移除空白/注释，重命名变量长度</li>
<li>代码分块：将功能块分成单独的包以便按需加载</li>
</ul>
</li>
<li>任务运行器<ul>
<li>Grunt：通过插件配置分开独立的任务</li>
<li>Gulp：通过一系列转换步骤得到的管道数据</li>
</ul>
</li>
<li>模块构建器<ul>
<li>Browserify：将CommonJS格式模块转成浏览器可用的代码</li>
<li>Webpack：将任何内容转成模块，主要用于浏览器（AMD/CJS/ES6 modules, CSS, images, …）</li>
</ul>
</li>
</ul>
<h3 id="现代工具：开发体验"><a href="#现代工具：开发体验" class="headerlink" title="现代工具：开发体验"></a>现代工具：开发体验</h3><ul>
<li>File watching / live reloading<ul>
<li>监听源文件的改变，重新编译，可能重新加载页面内容</li>
</ul>
</li>
<li>Sourcemaps<ul>
<li>调试信息将源文件的行与构建输出文件的行相关联。允许在浏览器中调试“原始”代码</li>
</ul>
</li>
<li>Browser dev tools<ul>
<li>元素检查，样式检查，脚本调试，网络流量监控</li>
</ul>
</li>
<li>Hot reloading<ul>
<li>快速交换重新编译的代码模块</li>
<li>实时编辑/所见即所得的开发体验</li>
<li>适合函数式编程技术</li>
</ul>
</li>
</ul>
<h3 id="现代工具：测试"><a href="#现代工具：测试" class="headerlink" title="现代工具：测试"></a>现代工具：测试</h3><ul>
<li>Test runners<ul>
<li>Mocha, Jasmine, Tape, Jest（主要用于浏览器以外环境）</li>
<li>Karma（在真实的浏览器环境里）</li>
</ul>
</li>
<li>Mocking and test behavior<ul>
<li>Chai, Expect（测试断言）</li>
<li>Sinon, JSDOM（网络/功能/DOM模拟）</li>
</ul>
</li>
<li>Integration testing<ul>
<li>Selenium（通过驱动浏览器进行集成测试）</li>
<li>PhantomJS（采用虚拟浏览器进行浏览器环境自动单元测试）</li>
</ul>
</li>
<li>Linting: ESLint</li>
<li>Static typing: Flow</li>
</ul>
<h3 id="现代工具：核心类库"><a href="#现代工具：核心类库" class="headerlink" title="现代工具：核心类库"></a>现代工具：核心类库</h3><ul>
<li>Express<ul>
<li>node环境HTTP服务端框架</li>
<li>中间件管道允许灵活处理请求/响应生命周期</li>
</ul>
</li>
<li>jQuery<ul>
<li>DOM处理和AJAX请求；抽象各浏览间的差异</li>
<li>单一广泛使用的JS类库</li>
<li><code>$(&#39;#someId&#39;).toogleClass(&#39;active&#39;)</code></li>
</ul>
</li>
<li>Underscore/Lodash<ul>
<li>非常有用的功能函数类库</li>
<li>Loadsh是Underscore的一个优化分支，额外添加了许多函数</li>
<li>数组（_.first），集合（_.forEach），对象（_.pick），字符串（_.camelCase），函数（_.debounce）等功能函数</li>
</ul>
</li>
</ul>
<h3 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h3><blockquote>
<p>每个框架都可以被看作是试图说“编写webapp的最困难的部分是$X，所以这里有一些代码让它更容易”。<br>当一个开发者“编写webapp最难的部分是实现双向数据绑定”，你可以使用knonchout.js，这个框架基本上能做90%的工作。···同样，Backbone感觉就是用来实现从一个REST API中获取并且持久化数据模型、客户端路由的产物，它基本上能做所有事。知道怎么将你获取的数据编程html内容（显然）容易，但是数据模型模型很难，所以这个工具能够帮助你。<br>如果您认为编写webapps的最大问题是Javascript不是Java、Ember不是Ruby，那么Angular就是你所需要的。（开玩笑了，我对这些框架并不熟悉）。等等，每个人都对最难处理的问题有自己的看法。<br>写webapp最难的是非确定的表现和不清晰的数据流动，React+Flux就是用来解决这些问题的。如果你已经在一个大型的Knockout或者Backbone项目上工作，你可能会倾向于同意。<br><a href="https://www.reddit.com/r/reactjs/comments/39wsfi/what_are_pros_and_cons_of_using_reactjsflux/cs7msvp" target="_blank" rel="noopener">Reddit /u/Cody_Chaos</a></p>
</blockquote>
<p><img src="/assets/201710/2017-10-11-javascript-frameworks.jpg" alt="2017-10-11-javascript-frameworks"></p>
<h4 id="JavaScript框架？！？"><a href="#JavaScript框架？！？" class="headerlink" title="JavaScript框架？！？"></a>JavaScript框架？！？</h4><ul>
<li>为什么会存在框架<ul>
<li>将状态移出DOM结构</li>
<li>高度抽象</li>
<li>代码组织</li>
</ul>
</li>
<li>优点<ul>
<li>可以在应用程序和开发人员之间共用常见概念</li>
<li>大型社区，共享知识，文档，错误修复</li>
<li>通过工具和指南达成更好的应用程序结构</li>
</ul>
</li>
<li>缺点<ul>
<li>学习曲线</li>
<li>项目大小最低要求</li>
<li>体系和基础设施</li>
</ul>
</li>
</ul>
<h4 id="JavaScript框架-1"><a href="#JavaScript框架-1" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h4><ul>
<li>BACKBONE.JS</li>
<li>ember</li>
<li>ANGULARJS</li>
<li>React</li>
</ul>
<h3 id="客户端路由（Client-Side-Routing）"><a href="#客户端路由（Client-Side-Routing）" class="headerlink" title="客户端路由（Client-Side Routing）"></a>客户端路由（Client-Side Routing）</h3><ul>
<li>“路由”：将URL映射到页面行为，包括从URL提取数据参数</li>
<li>最初是一个服务端概念</li>
<li>现代Web应用程序使用客户端上的路由能够快速更新和“深度链接”<ul>
<li>UI渲染</li>
<li>数据获取</li>
</ul>
</li>
<li>所有主流框架生态系统都包含路由器</li>
</ul>
<h3 id="状态-数据管理（State-Data-Management）"><a href="#状态-数据管理（State-Data-Management）" class="headerlink" title="状态/数据管理（State/Data Management）"></a>状态/数据管理（State/Data Management）</h3><ul>
<li>内置<ul>
<li>Backbone：Models/Collections</li>
<li>Ember：Ember Data</li>
<li>Angular 1: Services/Controllers</li>
</ul>
</li>
<li>React<ul>
<li>局部组件状态</li>
<li>“Flux”模式（单向数据流）</li>
<li>Redux（单状态树，不可变更新；采用Flux的逻辑理论）</li>
<li>MobX（依赖可观察进行跟踪）</li>
</ul>
</li>
<li>Angular 2<ul>
<li>Services/Controllers</li>
<li>Redux; Observables</li>
</ul>
</li>
</ul>
<h3 id="开发趋势：后端"><a href="#开发趋势：后端" class="headerlink" title="开发趋势：后端"></a>开发趋势：后端</h3><ul>
<li>“X即服务”</li>
<li>“无服务器”后端</li>
<li>微服务（Microservices）</li>
<li>容器（Containers）</li>
</ul>
<h3 id="开发趋势：客户端-服务端"><a href="#开发趋势：客户端-服务端" class="headerlink" title="开发趋势：客户端/服务端"></a>开发趋势：客户端/服务端</h3><ul>
<li>大规模的数据传输模式/工具<ul>
<li>GraphQL，Falcor</li>
</ul>
</li>
<li>“同构”/“通用”Javascript应用程序<ul>
<li>服务端渲染</li>
</ul>
</li>
<li>随处可见JavaScript<ul>
<li>跨平台工具包（Cordova，Ionic）</li>
<li>桌面应用（Electron）</li>
<li>移动应用（React Native）</li>
</ul>
</li>
</ul>
<h3 id="开发趋势：客户端"><a href="#开发趋势：客户端" class="headerlink" title="开发趋势：客户端"></a>开发趋势：客户端</h3><ul>
<li>基于组件的架构</li>
<li>“虚拟DOM”</li>
<li>CSS-in-JS</li>
<li>WebGL，Web Workers，Service Workers</li>
<li>替代语言（Elm，Clojurescript）</li>
</ul>
<h3 id="开发趋势：概念"><a href="#开发趋势：概念" class="headerlink" title="开发趋势：概念"></a>开发趋势：概念</h3><ul>
<li>函数式编程（Functional Programming）</li>
<li>不变数据(Immutable Data)</li>
<li>响应式编程/观测（Reactive Programming / Observables）</li>
<li>静态类型</li>
</ul>
<h2 id="打造一款现代Web-App"><a href="#打造一款现代Web-App" class="headerlink" title="打造一款现代Web App"></a>打造一款现代Web App</h2><h3 id="当前App"><a href="#当前App" class="headerlink" title="当前App"></a>当前App</h3><ul>
<li>用于内部使用的地理空间可视化工具</li>
<li>Version 1<ul>
<li>GWT+SmartGWT</li>
<li>Google Earth Plugin</li>
<li>Play Framework</li>
</ul>
</li>
</ul>
<h3 id="重写计划"><a href="#重写计划" class="headerlink" title="重写计划"></a>重写计划</h3><ul>
<li>GWT关注<ul>
<li>升级问题和框架的未来（可能即将到来的不兼容版本）</li>
<li>低能的开发工具</li>
<li>GWT特定的客户端-服务器通信与耦合</li>
</ul>
</li>
<li>v2原型/分析目标<ul>
<li>不被弃用的现代化工具技术栈</li>
<li>改进的开发体验（快速重建，热重新加载，易于测试）</li>
<li>更好的可维护性（代码结构，调试，数据流/跟踪）</li>
</ul>
</li>
<li>v2原型技术栈<ul>
<li>语言：ES6</li>
<li>UI框架：React</li>
<li>数据管理：Redux</li>
<li>构建工具：Webpack+Babel</li>
<li>测试：Mocha</li>
<li>3D地球：Cesium</li>
<li>风格：Semantic-UI</li>
</ul>
</li>
<li>为什么使用React和Redux？<ul>
<li>函数式编程原则，而且带有可靠的用法</li>
<li>状态/数据/更新的显式跟踪；单向数据流使得跟踪更容易</li>
<li>高度推荐使用的UI和逻辑</li>
<li>开发能力，如time-travel调试和热重载加快开发</li>
</ul>
</li>
</ul>
<h3 id="原型进展"><a href="#原型进展" class="headerlink" title="原型进展"></a>原型进展</h3><ul>
<li>v2原型demo<ul>
<li>File watching and recompiling</li>
<li>UI hot reloading</li>
<li>Data editing</li>
<li>Redux DevTools and time travel debugging</li>
<li>Test running</li>
</ul>
</li>
</ul>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><ul>
<li>Web历史<ul>
<li><a href="https://segment.com/blog/the-deep-roots-of-js-fatigue/" target="_blank" rel="noopener">The Deep Roots of Javascript Fatigue</a></li>
<li><a href="http://www.keepsite.com/a-brief-history-of-the-web/" target="_blank" rel="noopener">A Brief History of the Web</a></li>
<li><a href="https://mgadams.com/modern-javascript-development-part-1-d271f3790c1c" target="_blank" rel="noopener">The Golden Age of Javascript</a></li>
</ul>
</li>
<li>现代Web技术<ul>
<li><a href="https://www.infoq.com/articles/state-of-javascript-2016" target="_blank" rel="noopener">State of the Javascript Landscape: A Map for Newcomers</a></li>
<li><a href="http://marcobotto.com/the-hitchhikers-guide-to-the-modern-front-end-development-workflow/" target="_blank" rel="noopener">The Hitchhiker’s Guide to the Modern Front End Development Workflow</a></li>
<li><a href="http://jargon.js.org/" target="_blank" rel="noopener">Simplified Javascript Jargon</a></li>
<li><a href="https://medium.com/javascript-and-opinions/state-of-the-art-javascript-in-2016-ab67fc68eb0b" target="_blank" rel="noopener">State of the Art Javascript in 2016</a></li>
<li><a href="http://wesbos.com/overwhelmed-with-web-development/" target="_blank" rel="noopener">On Being Overwhelmed With Our Fast-Paced Industry</a></li>
<li><a href="http://stateofjs.com/" target="_blank" rel="noopener">The State of Javascript in 2016: Survey Results</a></li>
</ul>
</li>
</ul>
<p>这篇文章整理翻译自一篇讲稿，出处链接地址：<a href="http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/" target="_blank" rel="noopener">http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Promise有哪些使用技巧？]]></title>
      <url>http://yoursite.com/2017/09/30/promise-pro-tips/</url>
      <content type="html"><![CDATA[<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>这个方法用来一次执行多个promise非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    promise1,</span><br><span class="line">    promise2</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>这个方法用来包装同步代码，使之成为一个promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (somethingNotRight()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I will be rejected asynchronously!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'This string will be resolved asynchronously!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise执行链"><a href="#Promise执行链" class="headerlink" title="Promise执行链"></a>Promise执行链</h3><p>有时候需要一个一个promise顺序执行，下面的技巧可以实现这个想法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialize</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chain = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promiseFactorires.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">        chain = chain.then(promiseFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>这个擅长处理一个定时任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(reject, <span class="number">1000</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">    doSomethingThatMayTakeAwhile()</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally"></a>Promise.finally</h3><p>这个方法类似Q.finally，像这样使用：<code>promise.then(...).catch(...).finally(...)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finally</span>(<span class="params">promise, cb</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> promies2 = cb();</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> promise2 = cb();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> reason;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6测试解答]]></title>
      <url>http://yoursite.com/2017/09/24/es6-quiz-answer-explain/</url>
      <content type="html"><![CDATA[<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">func.name</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&quot;&quot;</code></li>
<li><code>&quot;func&quot;</code></li>
<li><code>&quot;anonymous&quot;</code></li>
<li><code>undefined</code></li>
</ol>
<p>这道题考察ES6中function的name属性，ES6会返回实际的函数名，而ES5则返回空字符串，因此这道题的结果是 <span style="color:#F92672;">func</span>。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DOLPHIN = <span class="string">"\ud83d\udc2c"</span>;</span><br><span class="line">DOLPHIN.length + [...DOLPHIN].length</span><br></pre></td></tr></table></figure>
<ol>
<li>2</li>
<li>3</li>
<li>4</li>
</ol>
<p>这道题涉及到ES6中Unicode字符，DOLPHIN.length返回长度为2，这是因为JavaScript内部字符以UTF-16的格式存储，每个字符固定为2个字节，因此DOLPHIN被认为为两个字符；[…DOLPHIN]用来解构字符串，结果是一个字符，因此[…DOLPHIN].length值为1。所以这个题的答案是 <span style="color:#F92672;">3</span>。</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(),</span><br><span class="line">    sym2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;,</span><br><span class="line">    o2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o2, &#123;</span><br><span class="line">    [sym1]: &#123;<span class="attr">value</span>: <span class="string">'Sym 1'</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    [sym2]: &#123;<span class="attr">value</span>: <span class="string">'Sym 2'</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.assign(o1, o2);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertSymbols(o1).lenght + <span class="built_in">Object</span>.getOwnPropertySymbols(o2).length;</span><br></pre></td></tr></table></figure>
<ol>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
</ol>
<p>这道题考察了Object对象三个方法的使用，defineProperties方法用来定义对象的属性以及其特性（是否可写，可配置，可枚举）；assign方法用来拷贝对象的属性，但是不可枚举的属性不会引入新对象中；getOwnPropertSymbols方法用来获取所有Symbol属性，包括不可枚举的Symbol属性。因此o1含有Symbol属性长度为1, o2含有Symbol属性长度为2，程序运行结果为 <span style="color:#F92672;">3</span>。</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;[<span class="string">"__proto__"</span>]: <span class="string">"FOO"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">__proto__</span>: <span class="string">"FOO"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;<span class="string">"__proto__"</span>: <span class="string">"FOO"</span>&#125;;</span><br><span class="line">[</span><br><span class="line">    obj1.hasOwnProperty(<span class="string">"__proto__"</span>),</span><br><span class="line">    obj2.hasOwnProperty(<span class="string">"__proto__"</span>),</span><br><span class="line">    obj3.hasOwnProperty(<span class="string">"__proto__"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li><code>[true, true, true]</code></li>
<li><code>[true, false, false]</code></li>
<li><code>[true, false, false]</code></li>
<li><code>[false, false, false]</code></li>
<li><code>[false, true, true]</code></li>
<li>thrown <code>TypeError</code></li>
</ol>
<p>__proto__魔法属性与非计算属性名的关系，可以看这里的运行原理<a href="https://tc39.github.io/ecma262/#sec-__proto__-property-names-in-object-initializers" target="_blank" rel="noopener">__proto__ Property Names in Object Initializers</a>。这道题的运行结果为 <span style="color:#F92672;">[true, false, false]</span>。</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>]; &#125;;</span><br><span class="line">    <span class="keyword">return</span> arrow(b);</span><br><span class="line">&#125;;</span><br><span class="line">foo(<span class="string">"A"</span>, <span class="string">"B"</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>“A”</li>
<li>“B”</li>
<li>thrown “TypeError”</li>
</ol>
<p>这道题考察了arrow函数定义与运行时arguments指向，arrow函数在定义时已经将arguments绑定在词法中，类似this、super和new.target，因此结果为 <span style="color:#F92672;">A</span>。</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="string">"BAR"</span> &#125;;</span><br><span class="line"><span class="keyword">typeof</span> f();</span><br></pre></td></tr></table></figure>
<ol>
<li>“string”</li>
<li>“object”</li>
<li>“undefined”</li>
</ol>
<p>箭头函数里面的内容不会被解析成对象字面量，但是会作为区块和标记声明。没有包含return语句，所以return的值为 <span style="color:#F92672;">underfined</span>。</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="built_in">String</span>.raw\<span class="string">`Line\nTerminator\` == "Line\\nTerminator",</span></span><br><span class="line"><span class="string">    \`\u3042\` == "\u3042",</span></span><br><span class="line"><span class="string">    String.raw\`\u3042\` == "\u3042"</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>[true, true, true]</code></li>
<li><code>[false, true, true]</code></li>
<li><code>[true, true, false]</code></li>
<li><code>[false, true, false]</code></li>
</ol>
<p>模板字符串与普通字符串的关系、模板字符串处理String.raw会将没有转义的字符转义。数组的结果为 <span style="color:#F92672;">[true, true, false]</span>。</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"out"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo(n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n) &#123; <span class="keyword">return</span> <span class="string">"in"</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> foo(<span class="number">1</span>) + <span class="string">"side"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>
<p>这道题比较迷惑的是obj.foo函数内的foo函数指向哪个函数，这个foo(1)执行调用的函数是外部定义的foo函数，没有绑定在obj对象上。运行结果为 <span style="color:#F92672;">outside</span>。</p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"FOO"</span>; &#125; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> f();</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&quot;object&quot;</code></li>
<li><code>&quot;function&quot;</code></li>
<li><code>&quot;undefined&quot;</code></li>
<li>thrown <code>SyntaxError</code></li>
</ol>
<p>箭头函数内部解析成标记声明，但是缺乏function名字，导致了语法错误。结果是 <span style="color:#F92672;">thrown SyntaxError</span>。</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"FOO"</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">typeof</span> f();</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&quot;object&quot;</code></li>
<li><code>&quot;function&quot;</code></li>
<li><code>&quot;undefined&quot;</code></li>
<li>thrown <code>SyntaxError</code></li>
</ol>
<p>在strict模式下标记函数声明（<a href="https://tc39.github.io/ecma262/#sec-labelled-function-declarations" target="_blank" rel="noopener">Labelled Function Declarations</a>）会出现语法错误。这道题的结果自然为 <span style="color:#F92672;">thrown SyntaxError</span>。</p>
<h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"obj"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.Foo.prototype = &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> obj.Foo();</span><br><span class="line">[</span><br><span class="line">    obj.name, foo.name</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<ol>
<li><code>[&quot;obj&quot;, undefined]</code></li>
<li><code>[&quot;Foo&quot;, undefined]</code></li>
<li><code>[undefined, &quot;Foo&quot;]</code></li>
<li>thrown <code>SyntaxError</code></li>
<li>thrown <code>TypeError</code></li>
</ol>
<p>ES6中对象的属性简洁表示法中，函数作为对象的方法定义不具有[[Construct]]内部方法。obj.Foo()只是一个函数而不是构造函数，不能用new操作，出现 <span style="color:#F92672;">thrown TypeError</span>。</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">arg1, ...rest</span>) </span>&#123;</span><br><span class="line">    arg1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>这道题涉及到<a href="https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation" target="_blank" rel="noopener">函数声明</a>和函数参数内部机制，当函数参数出现rest参数时argmuments被创建成<a href="https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject" target="_blank" rel="noopener">UnmappedArgumentsObject</a>对象。unmapped argument object意味着函数在传实参后arguments对象值不会再改变。创建成这种参数对象的情况还有以下几种：严格模式下、非严格模式下某些情况（含有rest参数、任何具有初始值的参数、任何具有解构参数）。所以这道题的结果是 <span style="color:#F92672;">1</span>。</p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([</span><br><span class="line">    <span class="number">1</span> <span class="keyword">in</span> <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">    <span class="number">1</span> <span class="keyword">in</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>),</span><br><span class="line">    <span class="number">1</span> <span class="keyword">in</span> <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">3</span>)),</span><br><span class="line">    <span class="number">1</span> <span class="keyword">in</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(),</span><br><span class="line">    <span class="number">1</span> <span class="keyword">in</span> [...[,,,]]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>[false, true, true, false, true]</code></li>
<li><code>[false, false, false, false, false]</code></li>
<li><code>[false ,false, true, true, true]</code></li>
</ol>
<p>这道题考察了稀疏数组和稠密数组的生成与区别，稀疏数组与稠密数组的不同是数组每项元素是否都存在，稀疏数组不存在的元素项不可遍历。ES6的方法会将稀疏数组转化成稠密数组，默认是undefined值。上面的结果是 <span style="color:#F92672;">[false, false, true, true, true]</span>。</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstUndefined</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        result.push(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].some(findFirstUndefined);</span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].find(findFirstUndefined);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>[1, 1]</code></li>
<li><code>[]</code></li>
<li><code>[1]</code></li>
<li>thrown <code>TypeError</code></li>
</ol>
<p>ES5中的遍历方法会忽略空的数组项，ES6会把空的数组项设为undefined。上面的result值为 <span style="color:#F92672;">[1]</span>。</p>
<h3 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPrototypeChainOf</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototypeChain = [];</span><br><span class="line">    <span class="keyword">while</span>(obj = <span class="built_in">Object</span>.getPrototypeOf(obj)) &#123;</span><br><span class="line">        prototypeChain.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prototypeChain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">getPrototypeChainOf(g()).length;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>2</code></li>
<li><code>3</code></li>
<li><code>4</code></li>
<li><code>5</code></li>
</ol>
<p>这道题涉及到generator函数原型链方面的知识。从generator函数原型一直往上遍历的原型顺序分别为：Genetator、GeneratorFunction、Symbol.iterator、Object。所得到的原型链长度为 <span style="color:#F92672;">4</span>。</p>
<h3 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">"1"</span>, <span class="literal">NaN</span>, <span class="number">3</span>, <span class="string">"a"</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">c, p</span>) =&gt;</span> c + p;</span><br><span class="line">[</span><br><span class="line">    list.map(<span class="built_in">Number</span>.isNaN).reduce(sum),</span><br><span class="line">    list.map(<span class="built_in">isNaN</span>).reduce(sum)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ol>
<li><code>[1, 1]</code></li>
<li><code>[1, 2]</code></li>
<li><code>[2, 1]</code></li>
<li><code>[2, 2]</code></li>
</ol>
<p>这道题需要区分Number.isNaN和isNaN方法，两者的不同点是前者不会对输入数据进行类型转化直接判断结果，只有NaN为true，其他都为false。上面数组的结果是 <span style="color:#F92672;">[1, 2]</span>。</p>
<h3 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    length: <span class="number">3</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(obj).length;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>2</code></li>
<li><code>3</code></li>
<li>thrown <code>TypeError</code></li>
</ol>
<p><a href="https://tc39.github.io/ecma262/#sec-array.from" target="_blank" rel="noopener">Array.from</a>会将伪数组和可迭代对象转换成数组对象，判断其长度会先去看迭代器的内容，因此上面的结果是 <span style="color:#F92672;">2</span>。</p>
<p>问题来源：<a href="https://gist.github.com/teramako/858c448cb76cb8d309b0" target="_blank" rel="noopener">https://gist.github.com/teramako/858c448cb76cb8d309b0</a></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git主干和分支开发最佳实践]]></title>
      <url>http://yoursite.com/2017/09/18/git-best-practise/</url>
      <content type="html"><![CDATA[<p>平时工作中需要接触Git版本管理，这次对Git进行一个整体的梳理。</p>
<h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><h4 id="什么是“版本控制”？"><a href="#什么是“版本控制”？" class="headerlink" title="什么是“版本控制”？"></a>什么是“版本控制”？</h4><p>一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h4 id="“版本控制”类别"><a href="#“版本控制”类别" class="headerlink" title="“版本控制”类别"></a>“版本控制”类别</h4><ul>
<li>本地版本控制系统，如RCS</li>
<li>集中化的版本控制系统，如CVS、Subversion、Perforce等</li>
<li>分布式版本控制系统，如Git、Mercurial、Bazaar、Darcs等</li>
</ul>
<h4 id="Git版本控制系统特点"><a href="#Git版本控制系统特点" class="headerlink" title="Git版本控制系统特点"></a>Git版本控制系统特点</h4><ul>
<li>直接记录快照，而非差异比较</li>
<li>近乎所有操作都是本地执行</li>
<li>Git保证完整性</li>
<li>Git一般只添加数据</li>
</ul>
<p><img src="/assets/201709/2017-09-18-git-feature.png" alt="git-feature"></p>
<h4 id="Git版本控制系统三种状态"><a href="#Git版本控制系统三种状态" class="headerlink" title="Git版本控制系统三种状态"></a>Git版本控制系统三种状态</h4><ul>
<li>已提交（committed）</li>
<li>已修改（modified）</li>
<li>已暂存（staged）</li>
</ul>
<p>工作流程：</p>
<ol>
<li>在工作目录中修改文件</li>
<li>暂存文件，将文件的快照放入暂存区域</li>
<li>提交更新，找到暂存区域文件，将快照永久性存储到Git仓库目录</li>
</ol>
<p><img src="/assets/201709/2017-09-18-git-process.png" alt="git-process"></p>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><ul>
<li>获取Git仓库：git init、git clone</li>
<li>检查Git状态：git status、git log</li>
<li>Git文件操作：git add、git rm、git mv、git diff</li>
<li>Git提交操作：git commit、git reset、git revert</li>
<li>远程仓库使用：git pull、git remote、git fetch、git push</li>
<li>Git打上标签：git tag</li>
<li>Git分支操作： git checkout 、git branch 、git merge、git rebase 、git stash</li>
</ul>
<h3 id="Git开发实践方式"><a href="#Git开发实践方式" class="headerlink" title="Git开发实践方式"></a>Git开发实践方式</h3><p>Git开发分为主干开发和分支开发。主干开发是所有用户开发、测试、发布上线基于一个分支上，默认为master分支的开发方式。分支开发是开发、测试、发布上线基于不同分支上，在适当的时候进行分支合并的开发方式。</p>
<h4 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h4><p>Git主分支的名字，默认叫做master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>
<p>适合场景：</p>
<ul>
<li>个人项目</li>
<li>项目需求变更少</li>
<li>不需要团队多人员协作的项目</li>
</ul>
<p>最佳实践：</p>
<ul>
<li>应该以实现一个需求点为前提提交，不可将未完全实现的代码提交</li>
<li>发布应该进行标记，利于查看发布记录</li>
</ul>
<p><img src="/assets/201709/2017-09-18-git-master-develop.png" alt="git-master-develop"></p>
<h4 id="分支开发"><a href="#分支开发" class="headerlink" title="分支开发"></a>分支开发</h4><p>分支开发背景</p>
<ol>
<li>经过多个开发周期，发布多个软件版本；每个发布的版本可能出现bug，需要对历史版本进行更改；</li>
<li>新版本开发与当前版本同步进行，混在一个分支中开发比较混乱；</li>
<li>客户功能定制开发，混在一个分支中必会带来混乱，多分支管理不善则带来定制功能迁移问题；</li>
<li>多人员多任务开发，任务开发周期不同，分支开发可避免冲突导致的效率低下；</li>
<li>敏捷开发，快速迭代编译</li>
</ol>
<p>最佳实践：<br>分为主分支和辅助分支，Main branches：master、develop，Supporting branches：feature branches、release branches、hotfix branches。<br>主分支：master分支和develop分支，master分支用来发布，HEAD就是当前线上运行代码；develop分支用于日常开发，开发完成并且测试没有问题再合入到master分支。<br>辅助分支：feature分支、release分支、hotfix分支，feature分支用来开发具体功能，一般fork自develop分支，最终合入develop分支；release分支可看作pre-master，可用来修复QA测试发现的问题，fork与合入分别来自develop分支；hotfix分支用来修复线上bug，基于master分支fork，hotfix修复过的代码需要分别合到master和develop分支，采用hotfix好处不打断develop分支正常进行，同时能修复现实代码中的问题。</p>
<p><img src="/assets/201709/2017-09-18-git-branch-develop.png" alt="git-branch-develop"></p>
]]></content>
      
        
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript语言对象扩展小结]]></title>
      <url>http://yoursite.com/2017/09/16/ecmascript-language-object-extensions-2017/</url>
      <content type="html"><![CDATA[<p>ECMAScript语言发展越来越迅速，ES5之前好几年才发布一次新的标准规范，从ES6 (ECMAScript 2015)开始，每年发布一次标准规范，基于向后兼容的原则对语言进行功能扩展使得开发效率越来越高。</p>
<p>下面将ECMAScript在数值、字符串、数组、对象、函数、正则表达式上的扩展做一个小结。</p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>从ES5开始，在严格模式之中，八进制不在允许使用前缀<code>0</code>表示。ES6提供了二进制和八进制数值新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<p>数值对象方法在ES6中有一些变化，将全局方法isFinite()、isNaN()、parseInt()、parseFloat()放在了Number对象下，分别是Number.isFinite()、Number.isNaN()、Number.parseInt()、Number.parseFloat()。全局方法和Number对象下isFinite()、isNaN()的这些方法的主要区别是全局方法在计算时会将参数先进行类型转换，转成数值再进行计算，而Number下的这些方法不会对参数类型转换直接进行计算。parseInt()、parseFloat()两者表现一致。</p>
<p>此外ES6还扩展了Number.EPSILON属性、Number.isInterger()方法、Number.MAX_SAFE_INTEGER属性、Number.MIN_SAFE_INTEGER属性、Number.isSafeInteger()方法。</p>
<p>Number.EPSILON是一个极小的常量，表示1与大于1的最小浮点数之间的差。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br></pre></td></tr></table></figure></p>
<p>Number.isInterger()方法用来判断一个值是否为整数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23.08</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量与JavaScript能够准确表示的整数范围有关，分别表示这个范围的上限和下限。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER</span><br><span class="line"><span class="comment">// -9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Number.isInterger()和Number.isSafeInteger()方法用来判断一个值是否为整数。它们之间的区别是后者判断一个整数是否落在JavaScript所能精确的数值范围内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES6在Math对象上新增了18个与数学相关的方法。所有方法都是静态方法，只能在Math对象上调用。其中包含了4个对数相关的方法，6个双曲函数方法。</p>
<p>ES2016新增了一个指数运算法（**），在V8引擎中指数运算符与Math.pow实现不相同，对于特别大的运算结果两者会有细微的差异。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">64</span> === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">64</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript是一组由16位组成的不可变的有序序列，每个字符通常来自于采用UTF-16编码的Unicode字符集。采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的Unicode码点，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符必须使用两个双字节的形式表示。</p>
<p>ES6中对直接跟在<code>\u</code>后面超过<code>0xFFFF</code>的数值做了一点改进，只要将码点放入大括号就能正确解读该字符。</p>
<p>在ES5中对字符串对象扩展了一个实例方法trim()，此方法用来移除字符串两侧的空白。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> org = <span class="string">' example '</span>;</span><br><span class="line">org.trim(); <span class="comment">// 'example'</span></span><br></pre></td></tr></table></figure></p>
<p>ES6中字符串扩展了一些方法，用来更便捷地处理字符串。字符串对象方法新增了：</p>
<ul>
<li>能够识别Unicode编号大于<code>0xFFFF</code>的码点返回对应字符 String.fromCodePoint()</li>
<li>模板字符串转义处理 String.raw()</li>
<li>实例方法新增了正确处理4个字节储存的字符返回其码点 codePointAt()</li>
<li>能够识别Unicode编号大于<code>0xFFFF</code>字符指定位置的字符 at()</li>
<li>字符不同表示方法统一同样形式（Unicode正规化）normalize()</li>
<li>确定一个字符串是否包含在另一个字符串中 includes()</li>
<li>参数字符串是否在原字符串的头部 startsWith()</li>
<li>参数字符串是否在原字符串的尾部 endsWith()</li>
<li>将原字符串重复<code>n</code>次返回的新字符串 repeat()</li>
</ul>
<p>ECAMScript 2017添加了两个字符串对象方法：</p>
<ul>
<li>字符串在头部补全长度返回新字符串 padStart()</li>
<li>字符串在尾部补全长度返回新字符串 padEnd()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "ஷ"</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hello\n<span class="subst">$&#123;<span class="number">2</span>*<span class="number">4</span>&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "Hello\n8!"</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'𠮷a'</span></span><br><span class="line">str.codePointAt(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 134071</span></span><br><span class="line">str.codePointAt(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 57271</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"><span class="string">'hello'</span>.at(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 'h'</span></span><br><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> compareStr = <span class="string">'Hello world!'</span></span><br><span class="line">compareStr.includes(<span class="string">'o'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">compareStr.startsWith(<span class="string">'world'</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">compareStr.endsWith(<span class="string">'!'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="string">'man'</span>.repeat(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 'manmanmanman'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// 'abcx'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// 'xabc'</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>ES5定义了9个新的数组方法来遍历forEach()、映射map()、过滤filter()、检测every()及some()、简化reduce()及reduceRight()和搜索数组indexOf()及lastIndexOf()。这些方法大多数第一次参数是一个函数，并且对数组每个元素调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。这些大多数数组方法第二个参数可选，若有第二个参数调用函数可看作是第二参数的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    sum += v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sum = 21</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, arr</span>) </span>&#123;</span><br><span class="line">    arr[i] = v * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// data = [2, 4, 6, 8, 10, 12]</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是forEach()不支持循环break终止语句，需要提前跳出循环只能用try…catch语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> all = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> allNew = all.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v*v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// allNew = [1, 4, 9]</span></span><br><span class="line"><span class="keyword">var</span> allPart = allNew.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// allPart = [1, 4]</span></span><br><span class="line">allPart.every(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">allPart.some(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> sum = all.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x +y;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// sum = 6</span></span><br><span class="line"><span class="keyword">var</span> big = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (2, 3) (9, 2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, accumulator);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// big = 512</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].indexOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].lastIndexOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>ES6中新增了扩展运算符（spread），三个点（…），作用是将一个数组转为用逗号分隔的参数序列。可用来复制数组、合并数组、与ES6解构赋值结合起来生成新数组、字符串转真正的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]; <span class="comment">// const [...a2] = a1;</span></span><br><span class="line"><span class="comment">// a2 = [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a3 = [...a1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// a3 = [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// first = 1, rest = [2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a4 = [...<span class="string">'hello'</span>];</span><br><span class="line"><span class="comment">// a4 = ['h', 'e', 'l', 'l', 'o']</span></span><br></pre></td></tr></table></figure></p>
<p>此外ES6也新增了一些数组方法：</p>
<ul>
<li>用于将类对象转为真正的数组 Array.from()</li>
<li>将一组值转为数组 Array.of()</li>
<li>在当前数组内部将指定位置的成员复制到其他位置返回新数组 copyWithin()</li>
<li>找出第一个符合条件的数组成员 find()</li>
<li>返回第一个符合条件的数组成员的位置 findIndex()</li>
<li>使用给定值填充数组返回新数组 fill()</li>
<li>遍历数组键名 keys()</li>
<li>遍历数组键值 values()</li>
<li>遍历数组键值对 entries()</li>
</ul>
<p>ECMAScript 2016新增了一个数组方法：</p>
<ul>
<li>数组是否包含某个值 includes()</li>
</ul>
<p>稀疏数组就是包含从0开始的不连续索引的数组，比起稠密数组实现上更慢、内存利用率更高、查找元素时间更长。可通过Array()构造函数或简单指定数组的索引值大于当前的数组长度创建稀疏数组，也可以通过delete操作符生产稀疏数组。数组空位是指数组的某一个位置没有任何值。</p>
<p>ES5对稀疏数组和数组空位处理大多数情况下会忽略空位。ES6则会将其转为undefined。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在ES5中属性的值可以是一个getter或setter函数（或两者都有），可以对对象创建的属性特性（property attribute）（可写writable、可枚举enumerable、可配置configurable）进行配置。有getter和setter定义的属性称作“存取器属性”（accessor property），它不同于由一个简单的值构成的数据属性。存取器属性不具有值特性和可写性。</p>
<p>ES5针对Object扩展了以下方法：</p>
<ul>
<li>使用指定的原型对象及其属性去创建一个新的对象 Object.create(proto[, propertiesObject])</li>
<li>直接在一个对象上定义一个新属性或者修改现有属性并返回这个对象 Object.defineProperty(obj, prop, descriptor) （descriptor描述符可选键值value, get, set, enumerable, writable, configurable）</li>
<li>直接在一个对象上定义新的属性或修改现有属性 Object.defineProperties(obj, props)</li>
<li>返回指定对象上一个自由属性对应的属性描述符 Object.getOwnPropertyDescriptor(obj, prop)</li>
<li>返回指定对象的所有自身属性（包括不可枚举属性但不包括Symbol值为名称的属性）组成的数组 Object.getOwnPropertyNames(obj)</li>
<li>返回指定对象的原型（即内部[[Prototype]]属性的值）Object.getPrototypeOf(object)</li>
<li>返回给定对象自身可枚举属性（不包含原型链上的属性）组成的数组 Object.keys(obj)</li>
<li>冻结一个对象（即对象永远不可变）Object.freeze(obj)</li>
<li>判断一个对象是否被冻结 Object.isFrozen(obj)</li>
<li>使一个对象变的不可扩展（即不能添加新的属性）Object.preventExtensions(obj)</li>
<li>判断一个对象是否是可扩展（能否在它上面添加新的属性）Object.isExtensible(obj)</li>
<li>将一个对象密封并返回被密封后的对象（只有可写属性不受影响）Object.seal(obj)</li>
<li>判断一个对象是否被密封 Object.isSealed(obj)</li>
</ul>
<p>ES6允许直接写入变量和函数作为对象的属性和方法，可在字面量定义对象时使用表达式作为对象的属性名，表达式放在方括号内。</p>
<p>ES6针对Object扩展了以下方法：</p>
<ul>
<li>比较两个值是否严格相等 Object.is(value1, value2)</li>
<li>将所有可枚举属性的值从一个或多个源对象复制到目标对象 Object.assign(target, …source)</li>
<li>设置一个指定对象原型到另一个对象或null Object.setPrototypeOf(obj, prototype)</li>
</ul>
<p>JavaScript语言中生成实例对象的传统方法是通过构造函数。ES6提供了更接近传统语言的写法，引入了Class（类）这个概念作为对象的模板，可通过<code>class</code>关键字定义类。</p>
<p>ECMAScript 2017在Object上新增了三个方法：</p>
<ul>
<li>返回一个给定对象自己的所有可枚举属性值的数组 Object.values(obj)</li>
<li>返回一个给定对象自身可枚举属性的键值对数组 Object.entries(obj)</li>
<li>获取一个对象的所有自身属性描述符 Object.getOwnPropertyDescriptors(obj)</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在ES5中新增了一个方法，用来改变函数调用时的this指向：fun.bind(thisArg[, arg1, [, arg2[, …]]])。</p>
<p>在ES6中可以指定函数参数的默认值，指定参数默认值后函数的length属性将返回没有指定默认值的参数个数。引入rest参数（形式为…变量名），用于获取函数多余的参数，rest参数能够将多余的参数放入一个数组中。ES6优化了尾调用性能。</p>
<p>ES6定义了一种新的函数定义方式，使用“箭头”（=&gt;）定义函数，简化了函数的定义，函数体内的this对象是定义时所在的对象而不是使用时所在的对象。针对异步编程提出了一个解决方案为Generator函数。</p>
<p>ES2017引入了async函数，使得异步操作变得更加方便。async函数实为Generator函数的语法糖。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>ES5中用正则表达式创建的RegExp对象运行时实例独立，ES3则共享同一个实例。</p>
<p>ES6允许用RegExp构造函数第一个参数是正则对象时，第二个参数可指定修饰符，并且会忽略原有正则表达式的修饰符。</p>
<p>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()、split()，ES6将这4个方法在语言内部全部调用RegExp的实例方法，从而做到所有正则相关的方法全都定义在RegExp对象上。</p>
<p>ES6对正则表达式添加了u修饰符（Unicode模式）、y修饰符（粘连修饰符）、s修饰符（dotAll模式），同时新增了sticky属性（是否设置y修饰符）、flags属性（返回正则表达式的所有修饰符）、dotAll属性（是否设置s修饰符）。</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React编码规范]]></title>
      <url>http://yoursite.com/2017/08/30/react-code-style/</url>
      <content type="html"><![CDATA[<h2 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h2><p>· [强制]同一目录下不得拥有同名的.js和.jsx文件。<br>  在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。</p>
<p>· [强制]组件文件使用一致的.js或.jsx后缀。<br>  所有组件文件的后缀从.js或.jsx中任选其一。<br>  不应在项目中出现部分组件为.js文件，部分为.jsx情况。</p>
<p>· [强制]每一个文件以export default的形式暴露一个组件。<br>  允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其他组件均定义为内部组件。</p>
<p>· [强制]每个存在组建的目录使用一个index.js以命名导出的形式暴露所有组件。<br>  同目录内的组件相互引用使用<code>import Foo from &#39;./Foo&#39;;</code>进行。<br>  引用其他目录的组件使用<code>import {Foo} from &#39;../component&#39;;</code>进行。<br>  建议使用VSCode的export-index插件自动生成index.js内容。</p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>· [强制]组件名为PascalCase。<br>  包括函数组件，名称均为PasCalCase。</p>
<p>· [强制]组件名称与文件名称保持相同。<br>  同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。</p>
<p>· [强制]高阶组件使用camelCase命名。<br>  高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。</p>
<p>· [强制]使用onXxx形式作为props中用于回调的属性名称。<br>  使用统一的命名规则用以区分props中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。<br>  对于不用于回调函数类型的属性，使用动词作为属性名称。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onClick作为回调函数以on开头，renderText非回调函数则使用动词</span></span><br><span class="line"><span class="keyword">let</span> Label = <span class="function">(<span class="params">&#123;onClick, renderText&#125;</span>) =&gt;</span> &lt;span onClick=&#123;onClick&#125;&gt;&#123;renderText()&#125;&lt;<span class="regexp">/span&gt;;</span></span><br></pre></td></tr></table></figure></p>
<p>· [建议]使用withXxx或xxxable形式的词作为高阶组件的名称。<br>  高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。</p>
<p>· [建议]作为组件方法的事件处理函数以具体业务含义的词作为名称，不使用onXxx形式命名。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    collectAndSubmitData() &#123;</span><br><span class="line">        <span class="keyword">let</span> data = &#123;</span><br><span class="line">            name: <span class="keyword">this</span>.state.name,</span><br><span class="line">            age: <span class="keyword">this</span>.state.age</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.props.onSubmit(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @autobind</span><br><span class="line">    syncName() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @autobind</span><br><span class="line">    syncAge() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;label&gt;姓名：&lt;input type=<span class="string">"text"</span> onChange=&#123;<span class="keyword">this</span>.syncName&#125;&gt;&lt;/label&gt;</span><br><span class="line">                &lt;label&gt;年龄：&lt;input type=<span class="string">"text"</span> onChange=&#123;<span class="keyword">this</span>.syncAge&#125;&gt;&lt;/label&gt;</span><br><span class="line">                &lt;button type=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.collectAndSubmit&#125;&gt;提交&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h2><p>· [强制]使用ES Class声明组件，禁止使用React.createClass。<br>  React v15.5.0已经弃用了React.createClass函数。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">let</span> Message = React.createClass(&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]不使用state的组件声明为函数组件。<br>  函数组件在React中有着特殊的地位，在将来也有可能得到更多的内部优化。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NextNumber</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.props.value + 1&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">let</span> NextNumber = <span class="function">(<span class="params">&#123;value&#125;</span>) =&gt;</span> &lt;span&gt;&#123;value + <span class="number">1</span>&#125;&lt;<span class="regexp">/span&gt;;</span></span><br></pre></td></tr></table></figure></p>
<p>· [强制]所有组件军需声明propTypes。<br>  propTypes在提升组件健壮性的同时，也是一种类似组件的文档的存在，有助于代码的阅读和理解。</p>
<p>· [强制]对于所有非isRequired的属性，在defaultProps中声明对应的值。<br>  声明初始值有助于对组件初始化的理解，也可以减少propTypes对类型进行校验产生的开销。<br>  对于初始没有值的属性，应当声明初始值为null而非undefined。</p>
<p>· [强制]如无必要，使用静态属性语法声明propTypes、contextTypes、defaultProps和state。<br>  仅当初始state需要从props计算得到的时候，才将state的声明放在构造函数中，其他情况下均适用静态属性声明进行。</p>
<p>· [强制]依照规定顺序编排组件中的方法和属性。<br>  按照以下顺序编排组件中的方法和属性：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static diplayName</span><br><span class="line">static propTypes</span><br><span class="line">static contextTypes</span><br><span class="line">static defaultProps</span><br><span class="line">static state</span><br><span class="line">其他静态的属性</span><br><span class="line">用于事件处理并且以属性的方式（onClick = e =&gt; &#123;...&#125;）声明的方法</span><br><span class="line">其他实例属性</span><br><span class="line">constructor</span><br><span class="line">getChildContext</span><br><span class="line">componentWillMount</span><br><span class="line">componentDidMount</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">componentDidUpdate</span><br><span class="line">componentWillUnmount</span><br><span class="line">事件处理方法</span><br><span class="line">其他方法</span><br><span class="line">render</span><br><span class="line"></span><br><span class="line">其中shouldComponentUpdate和render是一个组件最容易被阅读的函数，因此放在最下方由于快度定位。</span><br></pre></td></tr></table></figure></p>
<p>· [建议]无需显式引入React对象。<br>  使用JSX隐式地依赖当前环境下有React这一对象，但在源码上并没有显式使用，这种情况下添加<code>import React from &#39;react&#39;;</code>会造成一个没有使用的变量存在。<br>  使用babel-plugin-react-require插件可以很好地解决这一问题，因此无需显式地编写<code>import React from &#39;react&#39;;</code>这一语句。</p>
<p>· [建议]使用箭头函数声明函数组件。<br>  箭头函数具备更简洁的语法（无需function关键字），且可以在仅有一个语句时省去return造成的额外缩进。</p>
<p>· [建议]高阶组件返回新的组件类型时，添加displayName属性。<br>  同时在displayName上声明告诫组建的存在。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">let</span> asPureComponent = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> componentName = Component.displayName || Component.name || <span class="string">'UnknownComponent'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> displayName = <span class="string">`asPure(<span class="subst">$&#123;componentName&#125;</span>&#125;`</span>;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;Component &#123;..this.props&#125;/&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h2><p>· [强制]除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。<br>  本条规则并非要求组建继承自PureComponent，“概念上的纯组件”的意思为一个组件在props和state没有变化（shallowEqual）的情况下，渲染的结果应保持一直，即shouldComponentUpdate应当返回false。<br>  一个典型的非纯组件是使用了随机数或日期等函数：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> RandomNumber = <span class="function"><span class="params">()</span> =&gt;</span> &lt;span&gt;&#123;<span class="built_in">Math</span>.random&#125;&lt;<span class="regexp">/span&gt;;</span></span><br><span class="line"><span class="regexp">let Clock = () =&gt; &lt;span&gt;&#123;Date.time()&#125;&lt;/</span>span&gt;;</span><br></pre></td></tr></table></figure></p>
<p>  非纯组件具备向上的“传染性”，即一个包含非纯组件的组件必须是非纯组件，依然沿组件树结构向上。由于非纯组件无法通过shouldComponentUpdate优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。<br>  如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过props传递下来。对于使用Redux等应用状态管理的系统，可以在应用状态中存在相关的值（如Redux使用Action Creator生成这些值并通过Action和reducer更新到store中）。</p>
<p>· [强制]禁止为继承自PureComponent的组件编写shouldCOmponentUpdate实现。<br>  参考<a href="https://github.com/facebook/react/issues/9239" target="_blank" rel="noopener">React的相关Issue</a>，在React的实现中，PureComponent并不是直接实现shouldComponentUpdate，而是添加一个isReactPureComponent的标记，由CompositeComponent通过识别这个标记实现相关的逻辑。因此在PureComponent上自定义shouldComponentUpdate并无法享受super.shouldComponentUpdate的逻辑复用，会使得这个继承关系失去意义。</p>
<p>· [强制]为非继承自PureComponent的纯组件实现should方法。<br>  shouldComponentUpdate方法在React的性能中扮演者至关重要的角色，纯组件必定能通过props和state的变化来决定是否进行渲染，因此如果组件为纯组件且不继承shouldComponentUpdate，则应当有自己的shouldComponentUpdate实现来减少不必要的渲染。</p>
<p>· [建议]为函数组件添加PureComponent能力。<br>  函数组件并非一定是纯组件，因此其shouldComponentUpdate的实现为true，这可能导致额外的无意义渲染，因此推荐使用高阶组件为其添加shouldComponentUpdate的相关逻辑。<br>  推荐使用react-pure-stateless-component库实现这一功能。</p>
<p>· [建议]使用@autobind进行事件处理方法与this的绑定。<br>  由于PureComponent使用<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="noopener">shallowEqual</a>进行是否渲染的判断，如果在JSX中使用bind或箭头函数绑定this会造成子组件每次获取的函数都是一个新的引用，这破坏了shouldComponentUpdate的逻辑，引入了无意义的重复渲染，因此需要在render调用之前就将事件处理方法与this绑定，在每次render调用中获取同样的引用。<br>  当前比较流行的事前绑定this的方法有2种，其一使用类属性的方法：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    onClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  其二使用@autobind的装饰器：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    onClick(e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  使用类属性语法虽然可以避免引入一个autobind的实现，但存在一定的缺陷：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 对于新手不容易理解函数内部的this定义。</span><br><span class="line">· 无法在函数是使用其他的装饰器（如memoize、deprecated或检验相关的逻辑等）。</span><br><span class="line"></span><br><span class="line">因此，推荐使用@autobind装饰器实现this的事先绑定，推荐使用core-decorators库提供的相关装饰器实现。</span><br></pre></td></tr></table></figure></p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>· [强制]没有子节点的非DOM组件使用自闭合语法。<br>  对于DOM节点，按照HTML编码规范相关规则进行闭合，其中void element使用自闭合语法。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]保持起始和结束标签在同一层缩进。<br>  对于标签前面有其他语句（如return的情况，使用括号进行换行和缩进）。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">            &lt;span&gt;Hello World&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  对于直接return的函数组件，可以直接使用括号而省去大括号和return关键字：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Message = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于多属性需要换行，从第一个属性开始，每个属性一行。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有子节点</span></span><br><span class="line">&lt;SomComponent</span><br><span class="line">    longProp=&#123;longProp&#125;</span><br><span class="line">    anotherLongProp=&#123;anotherLongProp&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有子节点</span></span><br><span class="line">&lt;SomeComponent</span><br><span class="line">    longProp=&#123;longProp&#125;</span><br><span class="line">    anotherLongProp=&#123;anotherLongProp&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;SomeChild /&gt;</span><br><span class="line">    &lt;SomeChild /&gt;</span><br><span class="line">&lt;<span class="regexp">/SomeComponent&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>· [强制]以字符串字面量作为值的属性使用双引号（”），在其他类型表达式中的字符串使用单引号（’）。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</span><br><span class="line">&lt;Foo style=&#123;&#123;<span class="attr">width</span>: <span class="string">"20px"</span>&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</span><br><span class="line">&lt;Foo style=&#123;&#123;<span class="attr">width</span>: <span class="string">'20px'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]自闭合标签的/&gt;前添加一个空格。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span>/&gt;</span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span>  /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于值为true的属性，省去值部分。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo visible=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo visible /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于需要使用key的场合，提供一个唯一标识作为key属性的值，禁止使用可能会变化的属性（如索引）。<br>  key属性是React在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和正确性都无法得到保证。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&#123;list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;Foo key=&#123;index&#125; &#123;...item&#125; /&gt;)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span> &lt;Foo key=&#123;item.id&#125; &#123;...item&#125; /&gt;)&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [建议]避免在JSX的属性值中直接使用对象和函数表达式。<br>  PureComponent使用<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="noopener">shallowEqual</a>对props和state进行比较来决定是否需要渲染，而在JSX的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而shallowEqual会返回false，导致不必要的渲染。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnButton</span> </span>&#123;</span><br><span class="line">    alertMessage(message) &#123;</span><br><span class="line">        alert(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;button type="button" onClick=&#123;() =&gt; this.alertMessage(this.props.message)&#125;&gt;提示&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnButton</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    alertMessage() &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.props.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;button type="button" onClick=&#123;this.alertMessage&#125;&gt;提示&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [建议]将JSX的层级控制在3层以内。<br>  JSX提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对JSX的层级进行控制可以有效提升代码的可维护性。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">let</span> list = (&#123;items&#125;) = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">             items.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                 &lt;li&gt;</span><br><span class="line">                     &lt;header&gt;</span><br><span class="line">                         &lt;h3&gt;&#123;item.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                         &lt;span&gt;&#123;item.subtitle&#125;&lt;/</span>span&gt;</span><br><span class="line">                     &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">                     &lt;section&gt;&#123;item.content&#125;&lt;/</span>section&gt;</span><br><span class="line">                     &lt;footer&gt;</span><br><span class="line">                         &lt;span&gt;&#123;item.author&#125;&lt;<span class="regexp">/span&gt;@&lt;time&gt;&#123;time.postTime&#125;&lt;/</span>time&gt;</span><br><span class="line">                     &lt;<span class="regexp">/footer&gt;</span></span><br><span class="line"><span class="regexp">                 &lt;/</span>li&gt;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Good</span></span><br><span class="line"><span class="regexp">let Header = (&#123;title, subtitle&#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;header&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h3&gt;&#123;title&lt;/</span>h3&gt;</span><br><span class="line">        &lt;span&gt;&#123;subtitle&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>header&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Content = <span class="function">(<span class="params">&#123;content&#125;</span>) =&gt;</span> &lt;section&gt;&#123;content&#125;&lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let Footer = (&#123;author, postTime&#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;footer&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;author&#125;&lt;/</span>span&gt;@&lt;time&gt;&#123;postTime&#125;&lt;<span class="regexp">/time&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>footer&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Item = <span class="function">(<span class="params">&#123;item&#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Header &#123;...item&#125; /&gt;</span><br><span class="line">        &lt;Content &#123;...item&#125; /&gt;</span><br><span class="line">        &lt;Footer &#123;...item&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let List = (&#123;items&#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">        &#123;items.map(Item)&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用Chrome插件有哪些？]]></title>
      <url>http://yoursite.com/2017/08/08/chrome-common-plugin/</url>
      <content type="html"><![CDATA[<p>作为一名web开发者，会接触到很多开发工具，今天就来说说常用的chrome插件，利用这些插件给平时的工作、开发带来很大的便利。</p>
<h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><p>首选介绍这几个插件在浏览器使用过程中会有一些优化，它会给你带来什么样的体验呢？赶快去体验吧~</p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>Momentum插件用来替换Chrome新标签页内容，每天能看到不同优美的风景图片和精彩的格言。打开浏览器就能看到这么激励人心的内容，有木有给你的工作和生活带来动力？除此之外，该插件还提供了其他重要的功能，可以设置天气信息，待办事件记录，日常事务等等。</p>
<p><img src="/assets/201708/2017-08-08-momentum.png" alt="momentum"></p>
<h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><p>Chrome浏览器虽然访问页面很流畅，但是消耗内存也很大。OneTab字面意思即一个tab页面，当你用浏览器打开多个标签页，也许很多重要的内容没来得及看但又不想把它立即关掉，这时候你可以用OneTab插件来管理打开的tab标签页内容了。单击OneTab图标会将所有标签页转换成一个列表，在某个标签页可以选择左侧或右侧标签页放到OneTab列表页中。当再次访问这些标签页时可以从从这里恢复它们。将标签页放置到OneTab中，浏览器打开的标签页减少了，占用系统内存相应减少。</p>
<p><img src="/assets/201708/2017-08-08-onetab.png" alt="onetab"></p>
<h3 id="Proxy-SwitchySharp"><a href="#Proxy-SwitchySharp" class="headerlink" title="Proxy SwitchySharp"></a>Proxy SwitchySharp</h3><p>由于国内某些原因（你懂得），常常不能访问国外一些网站，这时候要访问这些内容时需要借助一些工具才能达到。这些工具就是代理，采用了代理浏览器则会通过代理去请求资源，从而绕开一些壁垒，请求到相应资源。Proxy SwitchSharp就是用来管理浏览器代理，可以将代理信息在这里设置从而达到“科学上网”。</p>
<p><img src="/assets/201708/2017-08-08-proxy-switchysharp.png" alt="proxy switchysharp"></p>
<h3 id="一键管理"><a href="#一键管理" class="headerlink" title="一键管理"></a>一键管理</h3><p>也许你的浏览器安装了不止一个插件，当你想把某个插件禁用或开启，没有安装此插件则需要到浏览器扩展程序页面中操作。一键管理插件会将浏览器安装过的所有插件放在一个控制面板中展示，所有插件一键开启或禁止，也可以针对某个插件开启或禁止。</p>
<p><img src="/assets/201708/2017-08-08-onekeyplugin.png" alt="onekeyplugin"></p>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>我们常常会在电脑上访问的页面用手机去浏览，比如开发测试无线页面效果，一般做法是将浏览器上访问的地址用手机浏览器打开，这样难以避免输入一串网址的烦恼，而且容易出错。有了这个插件，可以直接用手机扫描插件生成的二维码，从而快速访问到页面内容。</p>
<p><img src="/assets/201708/2017-08-08-qrcode.png" alt="qrcode"></p>
<h3 id="划词翻译"><a href="#划词翻译" class="headerlink" title="划词翻译"></a>划词翻译</h3><p>阅读外文资料时常常会遇到陌生的单词，这个时候鼠标轻轻一划其汉语意义就出来了，方便快捷，提升阅读理解效率。</p>
<p><img src="/assets/201708/2017-08-08-translate.png" alt="translate"></p>
<h2 id="Github相关"><a href="#Github相关" class="headerlink" title="Github相关"></a>Github相关</h2><p>github对于一个开发者来说并不陌生，github作为一个代码托管的在线服务，许多优秀的开发资源在这里涌现。Github最丰富的资源就是代码和文档，开发者可以从这里学习和利用到很多资源。下面介绍这几款与github相关的插件。</p>
<h3 id="Avatars-for-Github"><a href="#Avatars-for-Github" class="headerlink" title="Avatars for Github"></a>Avatars for Github</h3><p>登录用户访问github网站首页，呈现的是许多关注用户的一些动态信息，比如创建代码仓库、关注代码仓库、提及到代码、留言评论，网站默认不显示用户头像，只显示出用户名。人通常对图片比文字敏感，看到图片能更快获取到信息。使用了这个插件就能让页面中涉及的用户头像展示出来，浏览信息更加引起用户的注意力。</p>
<p><img src="/assets/201708/2017-08-08-avatars-for-github.png" alt="avatars for github"></p>
<h3 id="Insight-io-for-Github"><a href="#Insight-io-for-Github" class="headerlink" title="Insight.io for Github"></a>Insight.io for Github</h3><p>用户在访问一个仓库的源代码时通常是在各个目录和文件中来回切换，需要在页面中点击相应链接跳转才能实现。现在把这款强大的代码组织管理插件装上，你会越来越爱上这款插件。开启这个插件，在当前页面会展现代码的目录结构，单页面访问任何文件内容，展示文件的具体内容结构以及跨代码仓库查看文件内容引用。</p>
<p><img src="/assets/201708/2017-08-08-insight.io-for-github.png" alt="insight.io for github"></p>
<h3 id="Sourcegraph-for-Github"><a href="#Sourcegraph-for-Github" class="headerlink" title="Sourcegraph for Github"></a>Sourcegraph for Github</h3><p>装上这个插件当你在浏览代码、提交信息、diff信息时github像一个IDE一样，代码语法高亮显示，可以进行代码高级查找、跳转到代码定义所在行、发现代码相关引用。无论功能和效果都比上一个插件强大，不过使用这个插件会先打开一个新页面，然后加载内容展示。</p>
<p><img src="/assets/201708/2017-08-08-sourcegraph-for-github.png" alt="sourcegraph for github"></p>
<h3 id="octotree"><a href="#octotree" class="headerlink" title="octotree"></a>octotree</h3><p>启动这个插件，访问代码仓库时会展现代码结构树，便于代码浏览。</p>
<p><img src="/assets/201708/2017-08-08-octotree.png" alt="octotree"></p>
<h3 id="Github-Markdown-Menu"><a href="#Github-Markdown-Menu" class="headerlink" title="Github Markdown Menu"></a>Github Markdown Menu</h3><p>Github Markdown Menu会给readme或者Markdown文件生成一个导航目录。</p>
<p><img src="/assets/201708/2017-08-08-github-markdown-menu.png" alt="github markdown menu"></p>
<h2 id="前端框架相关"><a href="#前端框架相关" class="headerlink" title="前端框架相关"></a>前端框架相关</h2><p>Angular、React、Vue号称当前前端主流的三大框架，下面这几款插件就与它们息息相关，运用这些插件在程序调试过程中得心应手。</p>
<h3 id="AngularJS-Batarang"><a href="#AngularJS-Batarang" class="headerlink" title="AngularJS Batarang"></a>AngularJS Batarang</h3><p>这个插件为AngularJS框架扩展浏览器开发者工具功能，用来调试angularjs应用、性能测试。</p>
<p><img src="/assets/201708/2017-08-08-angularjs-batarang.png" alt="angularjs batarang"></p>
<h3 id="React-Developer-Tools"><a href="#React-Developer-Tools" class="headerlink" title="React Developer Tools"></a>React Developer Tools</h3><p>该插件为开源React.js JavaScript库扩展浏览器开发者工具功能，方便用户查看页面组件树结构关系。你可以在控制面板下选中组件展示其组件属性，也可以改变组件的pros和state内容。</p>
<p><img src="/assets/201708/2017-08-08-react-developer-tools.png" alt="react developer tools"></p>
<h3 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h3><p>这个插件为Vue.js框架扩展浏览器开发者工具功能，用来调试Vue.js应用程序，展示组件结构，跟踪组件数据流。</p>
<p><img src="/assets/201708/2017-08-08-vue.js-devtools.png" alt="vue.js devtools"></p>
<h2 id="开发工具相关"><a href="#开发工具相关" class="headerlink" title="开发工具相关"></a>开发工具相关</h2><p>除了上面这几款实用的插件，还有很多优秀的开发工具插件，下面列举我平时使用过的一些用于开发的插件。</p>
<h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>Postman并不是Chrome扩展程序，而是一个Chrome应用，这里把它列出来在于其在网络请求方面功能很强大。该插件可用来做API开发调试，支持多种请求方式。</p>
<p><img src="/assets/201708/2017-08-08-postman.png" alt="postman"></p>
<h3 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h3><p>在开发网络应用程序时，开启这个插件文件内容更新其展示页面会同步更新。</p>
<p><img src="/assets/201708/2017-08-08-livereload.png" alt="livereload"></p>
<h3 id="JSONView"><a href="#JSONView" class="headerlink" title="JSONView"></a>JSONView</h3><p>可用于校验json文件内容，格式化高亮展现json文件内容。</p>
<p><img src="/assets/201708/2017-08-08-jsonview.png" alt="jsonview"></p>
<h3 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a>FeHelper</h3><p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色、Ajax接口调试。</p>
<p><img src="/assets/201708/2017-08-08-fehelper.png" alt="fehelper"></p>
<h3 id="Sizzy"><a href="#Sizzy" class="headerlink" title="Sizzy"></a>Sizzy</h3><p>响应式网站调试工具，支持多种机型和尺寸。</p>
<p><img src="/assets/201708/2017-08-08-sizzy.png" alt="sizzy"></p>
<h3 id="Distill-Web-Monitor"><a href="#Distill-Web-Monitor" class="headerlink" title="Distill Web Monitor"></a>Distill Web Monitor</h3><p>Distill在您的浏览器上运行，检查监控的页面有无变更。在侦测到变更时立即发出通知。</p>
<p><img src="/assets/201708/2017-08-08-distill-web-monitor.png" alt="disll web monitor"></p>
<h3 id="Web-Developer"><a href="#Web-Developer" class="headerlink" title="Web Developer"></a>Web Developer</h3><p>一个拥有丰富功能的网页开发工具。</p>
<p><img src="/assets/201708/2017-08-08-web-developer.png" alt="web developer"></p>
<h3 id="HTML5-Outliner"><a href="#HTML5-Outliner" class="headerlink" title="HTML5 Outliner"></a>HTML5 Outliner</h3><p>生成一个带有标题和区域元素的html5页面轮廓结构。</p>
<p><img src="/assets/201708/2017-08-08-html5-outliner.png" alt="html5 outliner"></p>
<h3 id="Open-SEO-Stats"><a href="#Open-SEO-Stats" class="headerlink" title="Open SEO Stats"></a>Open SEO Stats</h3><p>显示当前网页的排名和 SEO 统计数据，主要包括 Alexa、Compete、Quantcast 排名，以及外链、索引数、IP 位置、Whois、SNS、缓存等。</p>
<p><img src="/assets/201708/2017-08-08-open-seo-stats.png" alt="open seo stats"></p>
<h3 id="Humans-txt"><a href="#Humans-txt" class="headerlink" title="Humans.txt"></a>Humans.txt</h3><p>如果网站存在humans.txt内容，可用来展现其具体内容。</p>
<p><img src="/assets/201708/2017-08-08-humans.png" alt="humans"></p>
]]></content>
      
        
        <tags>
            
            <tag> Tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一次重构静态网站浅谈]]></title>
      <url>http://yoursite.com/2017/07/29/refactor-static-website/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>静态网站顾名思义是由静态页面构成的网站，不涉及到后端数据库系统，页面中的内容在制作的时候就已经写好了。若需要去改某个页面的内容则需要找到该页面的模板文件修改。</p>
<p>最近收到了一个大学老师的消息，问我是否有空能帮她做个课题申报项目网站。我按照了项目开发的流程先打听了老师的项目需求，老师说该项目需求与在大学期间帮她做的那个课题申报项目类似，具体需求内容在此不多介绍了，主要是课题的一些相关内容需要采用网站的形式展示出来。</p>
<p>通过收藏夹打开了大学期间做的那个网站，网站挂靠在校园的服务器上，还能完好的访问。整个网站内容大致有7大板块，每个板块由侧边栏目录导航内容和右侧内容显示区块组成，整个网站大概有30个静态页面。我习惯性的会打开浏览器的控制台看页面结构和源码，发现页面中的资源引入和跳转链接全都采用了相对路径，出现了很多以.和..构成的链接，对我这种有整洁癖好的人引起了强迫症。</p>
<p>老师把四年前的源代码发给了我，我细看源码网站的内容由一个一个静态html页面组成，没有公共的模块内容，页面中的顶部图、导航条、版权栏都分散在各个页面中，没有独立出来。新的需求同样有这三块的内容，修改一处意味着每个页面都得改一次，严重影响了开发效率。基于此寻思着新的解决方案搭建这个静态网站。</p>
<h2 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h2><p>首先想到的是做这个静态网站能否像写博客那样，利用markdown语法书写各个页面的内容。但考虑到页面中的内容除了纯文本内容外，还包含了pdf文档、视频内容。对整个网站内容大致细分了各个组成模块，发现可以抽出一个基础的模板布局文件，将网站的顶部图片、导航条、版权栏内容单独抽出来，再分别引入到各个页面中，浏览pdf文档与观看视频功能可以制作成组件，在页面中通过使用组件就能方便快捷搭建内容。</p>
<p>基于上述的需求诉求，我采用了模板引擎来完成这些内容。模板引擎是个什么东西呢？模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p>
<p>模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。置换型模板引擎实现简单，但其效率低下，无法满足高负载的应用需求（比如有海量访问的网站），因此还出现了“解释型”模板引擎和“编译型”模板引擎等。模板引擎又分为前端模板引擎和后端模板引擎。后端模板引擎针对各种语言分别有相对应的模板引擎，像PHP语言比较知名的smarty，Java语言Velocity，Python语言Django等等。常见流行的前端模板引擎有artTemplate、Mustache、HandlebarsJS、EJS、Jade（新名pug）、Swig等等。</p>
<p>静态网站不涉及到后端内容，选用前端模板即可解决问题。那这么多前端模板引擎如何选择才能找到一个合适的模板引擎呢？在开发中有良好的运行调试能力，支持模板继承和文件引入，支持作用域变量和判断循环条件语句，拥有简洁的语法在一定条件下能减少代码书写量，拥有上述这些特点的模板引擎都能支撑起业务开发，于是我选择了pug模板引擎。</p>
<h2 id="实践思路"><a href="#实践思路" class="headerlink" title="实践思路"></a>实践思路</h2><h3 id="目录规划"><a href="#目录规划" class="headerlink" title="目录规划"></a>目录规划</h3><p>对一个静态网站来说，资源包含静态模板页面、样式文件、静态资源（如图片、视频、文档等等）。如何设计整个网站的目录结构对开发效率来说有很大的影响。目前大体上网站的目录结构有两种分类方式，一种是根据功能来划分目录结构，比如某个页面实现所需要的业务组件、样式都放在同一个目录里，这种对于业务功能比较复杂类应用来说尤为方便，资源查找和引用一目了然；另一种是根据文件类型来划分目录结构，这种对于网站文件管理比较方便。</p>
<p>根据这个静态网站的需求来开发，网站内容偏展示，不涉及复杂的页面交互逻辑，以文件类型为目录结构规划网站内容。</p>
<p><img src="/assets/201707/2017-07-project-directory.png" alt="目录结构图"></p>
<h3 id="开发细节"><a href="#开发细节" class="headerlink" title="开发细节"></a>开发细节</h3><p>得益于pug简洁的模板语法和强大的模板功能，pug在这个项目中发挥了很大作用。每个页面都是继承自base layout，其中base layout包括页面banner、nav、footer公用的组件，nav的状态可以通过在具体页面中传入变量实现。每个页面根据实际情况可以划分为侧边导航栏组件和内容区域，从而组成一个个具体的页面。</p>
<p>pdf文件浏览采用开源的pdf.js库，能够实现跨平台在线浏览pdf文件内容。视频文件考虑到文件格式兼容性和在线存储，使用了传统的flash流式播放。封装了这两个组件，在使用的时候采用参数传入的方式来调动功能，从而达到复用。</p>
<p>采用这种继承layout和组件形式开发，节省了很多开发工作量，开发效率得到很大提升，并且易于维护。</p>
<h3 id="构建部署"><a href="#构建部署" class="headerlink" title="构建部署"></a>构建部署</h3><p>现在每个网站的开发、测试、上线离不开一个构建部署脚本。node.js的不断发展，生态系统日益壮大，有很多方便快捷的工具可以用于开发构建。本项目用到了将pug模板编译成html内容，css和js文件压缩，浏览器同步自动更新构建工具，基于文件流和任务式自动化构建工具gulp.js，能够简单高效的完成网站的构建与部署。</p>
<p><img src="/assets/201707/2017-07-29-work-stream.png" alt="构建流程图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>完成整个网站开发涉及到了方方面面，一点一滴的积累和实践，得到了成长，收获了快乐。</p>
]]></content>
      
        
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
