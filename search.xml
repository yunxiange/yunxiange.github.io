<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ECMAScript语言对象扩展小结]]></title>
      <url>http://yoursite.com/2017/10/11/ecmascript-language-object-extensions-2017/</url>
      <content type="html"><![CDATA[<p>ECMAScript语言发展越来越迅速，ES5之前好几年才发布一次新的标准规范，从ES6 (ECMAScript 2015)开始，每年发布一次标准规范，基于向后兼容的原则对语言进行功能扩展使得开发效率越来越高。</p>
<p>下面将ECMAScript在数值、字符串、数组、对象、函数、正则表达式上的扩展做一个小结。</p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>从ES5开始，在严格模式之中，八进制不在允许使用前缀<code>0</code>表示。ES6提供了二进制和八进制数值新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<p>数值对象方法在ES6中有一些变化，将全局方法isFinite()、isNaN()、parseInt()、parseFloat()放在了Number对象下，分别是Number.isFinite()、Number.isNaN()、Number.parseInt()、Number.parseFloat()。全局方法和Number对象下isFinite()、isNaN()的这些方法的主要区别是全局方法在计算时会将参数先进行类型转换，转成数值再进行计算，而Number下的这些方法不会对参数类型转换直接进行计算。parseInt()、parseFloat()两者表现一致。</p>
<p>此外ES6还扩展了Number.EPSILON属性、Number.isInterger()方法、Number.MAX_SAFE_INTEGER属性、Number.MIN_SAFE_INTEGER属性、Number.isSafeInteger()方法。</p>
<p>Number.EPSILON是一个极小的常量，表示1与大于1的最小浮点数之间的差。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br></pre></td></tr></table></figure></p>
<p>Number.isInterger()方法用来判断一个值是否为整数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23.08</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量与JavaScript能够准确表示的整数范围有关，分别表示这个范围的上限和下限。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER</span><br><span class="line"><span class="comment">// -9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Number.isInterger()和Number.isSafeInteger()方法用来判断一个值是否为整数。它们之间的区别是后者判断一个整数是否落在JavaScript所能精确的数值范围内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ES6在Math对象上新增了18个与数学相关的方法。所有方法都是静态方法，只能在Math对象上调用。其中包含了4个对数相关的方法，6个双曲函数方法。</p>
<p>ES2016新增了一个指数运算法（**），在V8引擎中指数运算符与Math.pow实现不相同，对于特别大的运算结果两者会有细微的差异。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">64</span> === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">64</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript是一组由16位组成的不可变的有序序列，每个字符通常来自于采用UTF-16编码的Unicode字符集。采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的Unicode码点，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符必须使用两个双字节的形式表示。</p>
<p>ES6中对直接跟在<code>\u</code>后面超过<code>0xFFFF</code>的数值做了一点改进，只要将码点放入大括号就能正确解读该字符。</p>
<p>在ES5中对字符串对象扩展了一个实例方法trim()，此方法用来移除字符串两侧的空白。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> org = <span class="string">' example '</span>;</span><br><span class="line">org.trim(); <span class="comment">// 'example'</span></span><br></pre></td></tr></table></figure></p>
<p>ES6中字符串扩展了一些方法，用来更便捷地处理字符串。字符串对象方法新增了：<br>· 能够识别Unicode编号大于<code>0xFFFF</code>的码点返回对应字符 String.fromCodePoint()<br>· 模板字符串转义处理 String.raw()<br>· 实例方法新增了正确处理4个字节储存的字符返回其码点 codePointAt()<br>· 能够识别Unicode编号大于<code>0xFFFF</code>字符指定位置的字符 at()<br>· 字符不同表示方法统一同样形式（Unicode正规化）normalize()<br>· 确定一个字符串是否包含在另一个字符串中 includes()<br>· 参数字符串是否在原字符串的头部 startsWith()<br>· 参数字符串是否在原字符串的尾部 endsWith()<br>· 将原字符串重复<code>n</code>次返回的新字符串 repeat()</p>
<p>ECAMScript 2017添加了两个字符串对象方法：<br>· 字符串在头部补全长度返回新字符串 padStart()<br>· 字符串在尾部补全长度返回新字符串 padEnd()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "ஷ"</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hello\n<span class="subst">$&#123;2*4&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "Hello\n8!"</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'𠮷a'</span></span><br><span class="line">str.codePointAt(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 134071</span></span><br><span class="line">str.codePointAt(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 57271</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// '𠮷'</span></span><br><span class="line"><span class="string">'hello'</span>.at(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 'h'</span></span><br><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> compareStr = <span class="string">'Hello world!'</span></span><br><span class="line">compareStr.includes(<span class="string">'o'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">compareStr.startsWith(<span class="string">'world'</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">compareStr.endsWith(<span class="string">'!'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="string">'man'</span>.repeat(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 'manmanmanman'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// 'abcx'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// 'xabc'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>ES5定义了9个新的数组方法来遍历forEach()、映射map()、过滤filter()、检测every()及some()、简化reduce()及reduceRight()和搜索数组indexOf()及lastIndexOf()。这些方法大多数第一次参数是一个函数，并且对数组每个元素调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。这些大多数数组方法第二个参数可选，若有第二个参数调用函数可看作是第二参数的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    sum += v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sum = 21</span></span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v, i, arr</span>) </span>&#123;</span><br><span class="line">    arr[i] = v * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// data = [2, 4, 6, 8, 10, 12]</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是forEach()不支持循环break终止语句，需要提前跳出循环只能用try…catch语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> all = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> allNew = all.map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v*v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// allNew = [1, 4, 9]</span></span><br><span class="line"><span class="keyword">var</span> allPart = allNew.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// allPart = [1, 4]</span></span><br><span class="line">allPart.every(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">allPart.some(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> sum = all.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x +y;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// sum = 6</span></span><br><span class="line"><span class="keyword">var</span> big = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (2, 3) (9, 2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(value, accumulator);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// big = 512</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].indexOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].lastIndexOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].indexOf(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>ES6中新增了扩展运算符（spread），三个点（…），作用是将一个数组转为用逗号分隔的参数序列。可用来复制数组、合并数组、与ES6解构赋值结合起来生成新数组、字符串转真正的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1]; <span class="comment">// const [...a2] = a1;</span></span><br><span class="line"><span class="comment">// a2 = [1, 2, 3]</span></span><br><span class="line"><span class="keyword">const</span> a3 = [...a1, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// a3 = [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// first = 1, rest = [2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a4 = [...<span class="string">'hello'</span>];</span><br><span class="line"><span class="comment">// a4 = ['h', 'e', 'l', 'l', 'o']</span></span><br></pre></td></tr></table></figure></p>
<p>此外ES6也新增了一些数组方法：<br>· 用于将类对象转为真正的数组 Array.from()<br>· 将一组值转为数组 Array.of()<br>· 在当前数组内部将指定位置的成员复制到其他位置返回新数组 copyWithin()<br>· 找出第一个符合条件的数组成员 find()<br>· 返回第一个符合条件的数组成员的位置 findIndex()<br>· 使用给定值填充数组返回新数组 fill()<br>· 遍历数组键名 keys()<br>· 遍历数组键值 values()<br>· 遍历数组键值对 entries()</p>
<p>ECMAScript 2016新增了一个数组方法：<br>· 数组是否包含某个值 includes()</p>
<p>稀疏数组就是包含从0开始的不连续索引的数组，比起稠密数组实现上更慢、内存利用率更高、查找元素时间更长。可通过Array()构造函数或简单指定数组的索引值大于当前的数组长度创建稀疏数组，也可以通过delete操作符生产稀疏数组。数组空位是指数组的某一个位置没有任何值。</p>
<p>ES5对稀疏数组和数组空位处理大多数情况下会忽略空位。ES6则会将其转为undefined。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在ES5中属性的值可以是一个getter或setter函数（或两者都有），可以对对象创建的属性特性（property attribute）（可写writable、可枚举enumerable、可配置configurable）进行配置。有getter和setter定义的属性称作“存取器属性”（accessor property），它不同于由一个简单的值构成的数据属性。存取器属性不具有值特性和可写性。</p>
<p>ES5针对Object扩展了以下方法：<br>· 使用指定的原型对象及其属性去创建一个新的对象 Object.create(proto[, propertiesObject])<br>· 直接在一个对象上定义一个新属性或者修改现有属性并返回这个对象 Object.defineProperty(obj, prop, descriptor) （descriptor描述符可选键值value, get, set, enumerable, writable, configurable）<br>· 直接在一个对象上定义新的属性或修改现有属性 Object.defineProperties(obj, props)<br>· 返回指定对象上一个自由属性对应的属性描述符 Object.getOwnPropertyDescriptor(obj, prop)<br>· 返回指定对象的所有自身属性（包括不可枚举属性但不包括Symbol值为名称的属性）组成的数组 Object.getOwnPropertyNames(obj)<br>· 返回指定对象的原型（即内部[[Prototype]]属性的值）Object.getPrototypeOf(object)<br>· 返回给定对象自身可枚举属性（不包含原型链上的属性）组成的数组 Object.keys(obj)<br>· 冻结一个对象（即对象永远不可变）Object.freeze(obj)<br>· 判断一个对象是否被冻结 Object.isFrozen(obj)<br>· 使一个对象变的不可扩展（即不能添加新的属性）Object.preventExtensions(obj)<br>· 判断一个对象是否是可扩展（能否在它上面添加新的属性）Object.isExtensible(obj)<br>· 将一个对象密封并返回被密封后的对象（只有可写属性不受影响）Object.seal(obj)<br>· 判断一个对象是否被密封 Object.isSealed(obj)</p>
<p>ES6允许直接写入变量和函数作为对象的属性和方法，可在字面量定义对象时使用表达式作为对象的属性名，表达式放在方括号内。</p>
<p>ES6针对Object扩展了以下方法：<br>· 比较两个值是否严格相等 Object.is(value1, value2)<br>· 将所有可枚举属性的值从一个或多个源对象复制到目标对象 Object.assign(target, …source)<br>· 设置一个指定对象原型到另一个对象或null Object.setPrototypeOf(obj, prototype)</p>
<p>JavaScript语言中生成实例对象的传统方法是通过构造函数。ES6提供了更接近传统语言的写法，引入了Class（类）这个概念作为对象的模板，可通过<code>class</code>关键字定义类。</p>
<p>ECMAScript 2017在Object上新增了三个方法：<br>· 返回一个给定对象自己的所有可枚举属性值的数组 Object.values(obj)<br>· 返回一个给定对象自身可枚举属性的键值对数组 Object.entries(obj)<br>· 获取一个对象的所有自身属性描述符 Object.getOwnPropertyDescriptors(obj)</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在ES5中新增了一个方法，用来改变函数调用时的this指向：fun.bind(thisArg[, arg1, [, arg2[, …]]])。</p>
<p>在ES6中可以指定函数参数的默认值，指定参数默认值后函数的length属性将返回没有指定默认值的参数个数。引入rest参数（形式为…变量名），用于获取函数多余的参数，rest参数能够将多余的参数放入一个数组中。ES6优化了尾调用性能。</p>
<p>ES6定义了一种新的函数定义方式，使用“箭头”（=&gt;）定义函数，简化了函数的定义，函数体内的this对象是定义时所在的对象而不是使用时所在的对象。针对异步编程提出了一个解决方案为Generator函数。</p>
<p>ES2017引入了async函数，使得异步操作变得更加方便。async函数实为Generator函数的语法糖。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>ES5中用正则表达式创建的RegExp对象运行时实例独立，ES3则共享同一个实例。</p>
<p>ES6允许用RegExp构造函数第一个参数是正则对象时，第二个参数可指定修饰符，并且会忽略原有正则表达式的修饰符。</p>
<p>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()、split()，ES6将这4个方法在语言内部全部调用RegExp的实例方法，从而做到所有正则相关的方法全都定义在RegExp对象上。</p>
<p>ES6对正则表达式添加了u修饰符（Unicode模式）、y修饰符（粘连修饰符）、s修饰符（dotAll模式），同时新增了sticky属性（是否设置y修饰符）、flags属性（返回正则表达式的所有修饰符）、dotAll属性（是否设置s修饰符）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React编码规范]]></title>
      <url>http://yoursite.com/2017/08/30/react-code-style/</url>
      <content type="html"><![CDATA[<h2 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h2><p>· [强制]同一目录下不得拥有同名的.js和.jsx文件。<br>  在使用模块导入时，倾向于不添加后缀，如果存在同名但不同后缀的文件，构建工具将无法决定哪一个是需要引入的模块。</p>
<p>· [强制]组件文件使用一致的.js或.jsx后缀。<br>  所有组件文件的后缀从.js或.jsx中任选其一。<br>  不应在项目中出现部分组件为.js文件，部分为.jsx情况。</p>
<p>· [强制]每一个文件以export default的形式暴露一个组件。<br>  允许一个文件中存在多个不同的组件，但仅允许通过export default暴露一个组件，其他组件均定义为内部组件。</p>
<p>· [强制]每个存在组建的目录使用一个index.js以命名导出的形式暴露所有组件。<br>  同目录内的组件相互引用使用<code>import Foo from &#39;./Foo&#39;;</code>进行。<br>  引用其他目录的组件使用<code>import {Foo} from &#39;../component&#39;;</code>进行。<br>  建议使用VSCode的export-index插件自动生成index.js内容。</p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>· [强制]组件名为PascalCase。<br>  包括函数组件，名称均为PasCalCase。</p>
<p>· [强制]组件名称与文件名称保持相同。<br>  同时组件名称应当能体现出组件的功能，以便通过观察文件名即确定使用哪一个组件。</p>
<p>· [强制]高阶组件使用camelCase命名。<br>  高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。</p>
<p>· [强制]使用onXxx形式作为props中用于回调的属性名称。<br>  使用统一的命名规则用以区分props中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。<br>  对于不用于回调函数类型的属性，使用动词作为属性名称。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onClick作为回调函数以on开头，renderText非回调函数则使用动词</span></span><br><span class="line"><span class="keyword">let</span> Label = (&#123;onClick, renderText&#125;) =&gt; &lt;span onClick=&#123;onClick&#125;&gt;&#123;renderText()&#125;&lt;/span&gt;;</span><br></pre></td></tr></table></figure></p>
<p>· [建议]使用withXxx或xxxable形式的词作为高阶组件的名称。<br>  高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。</p>
<p>· [建议]作为组件方法的事件处理函数以具体业务含义的词作为名称，不使用onXxx形式命名。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    collectAndSubmitData() &#123;</span><br><span class="line">        <span class="keyword">let</span> data = &#123;</span><br><span class="line">            name: <span class="keyword">this</span>.state.name,</span><br><span class="line">            age: <span class="keyword">this</span>.state.age</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.props.onSubmit(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @autobind</span><br><span class="line">    syncName() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @autobind</span><br><span class="line">    syncAge() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;label&gt;姓名：&lt;input type="text" onChange=&#123;this.syncName&#125;&gt;&lt;/label&gt;</span><br><span class="line">                &lt;label&gt;年龄：&lt;input type="text" onChange=&#123;this.syncAge&#125;&gt;&lt;/label&gt;</span><br><span class="line">                &lt;button type="button" onClick=&#123;this.collectAndSubmit&#125;&gt;提交&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h2><p>· [强制]使用ES Class声明组件，禁止使用React.createClass。<br>  React v15.5.0已经弃用了React.createClass函数。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">let</span> Message = React.createClass(&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.state.message&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]不使用state的组件声明为函数组件。<br>  函数组件在React中有着特殊的地位，在将来也有可能得到更多的内部优化。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NextNumber</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;span&gt;&#123;this.props.value + 1&#125;&lt;/span&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">let</span> NextNumber = (&#123;value&#125;) =&gt; &lt;span&gt;&#123;value + 1&#125;&lt;/span&gt;;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]所有组件军需声明propTypes。<br>  propTypes在提升组件健壮性的同时，也是一种类似组件的文档的存在，有助于代码的阅读和理解。</p>
<p>· [强制]对于所有非isRequired的属性，在defaultProps中声明对应的值。<br>  声明初始值有助于对组件初始化的理解，也可以减少propTypes对类型进行校验产生的开销。<br>  对于初始没有值的属性，应当声明初始值为null而非undefined。</p>
<p>· [强制]如无必要，使用静态属性语法声明propTypes、contextTypes、defaultProps和state。<br>  仅当初始state需要从props计算得到的时候，才将state的声明放在构造函数中，其他情况下均适用静态属性声明进行。</p>
<p>· [强制]依照规定顺序编排组件中的方法和属性。<br>  按照以下顺序编排组件中的方法和属性：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static diplayName</span><br><span class="line">static propTypes</span><br><span class="line">static contextTypes</span><br><span class="line">static defaultProps</span><br><span class="line">static state</span><br><span class="line">其他静态的属性</span><br><span class="line">用于事件处理并且以属性的方式（onClick = e =&gt; &#123;...&#125;）声明的方法</span><br><span class="line">其他实例属性</span><br><span class="line">constructor</span><br><span class="line">getChildContext</span><br><span class="line">componentWillMount</span><br><span class="line">componentDidMount</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">componentDidUpdate</span><br><span class="line">componentWillUnmount</span><br><span class="line">事件处理方法</span><br><span class="line">其他方法</span><br><span class="line">render</span><br><span class="line"></span><br><span class="line">其中shouldComponentUpdate和render是一个组件最容易被阅读的函数，因此放在最下方由于快度定位。</span><br></pre></td></tr></table></figure></p>
<p>· [建议]无需显式引入React对象。<br>  使用JSX隐式地依赖当前环境下有React这一对象，但在源码上并没有显式使用，这种情况下添加<code>import React from &#39;react&#39;;</code>会造成一个没有使用的变量存在。<br>  使用babel-plugin-react-require插件可以很好地解决这一问题，因此无需显式地编写<code>import React from &#39;react&#39;;</code>这一语句。</p>
<p>· [建议]使用箭头函数声明函数组件。<br>  箭头函数具备更简洁的语法（无需function关键字），且可以在仅有一个语句时省去return造成的额外缩进。</p>
<p>· [建议]高阶组件返回新的组件类型时，添加displayName属性。<br>  同时在displayName上声明告诫组建的存在。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">let</span> asPureComponent = Component =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> componentName = Component.displayName || Component.name || <span class="string">'UnknownComponent'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> displayName = <span class="string">`asPure(<span class="subst">$&#123;componentName&#125;</span>&#125;`</span>;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;Component &#123;..this.props&#125;/&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h2><p>· [强制]除顶层或路由级组件以外，所有组件均在概念上实现为纯组件（Pure Component）。<br>  本条规则并非要求组建继承自PureComponent，“概念上的纯组件”的意思为一个组件在props和state没有变化（shallowEqual）的情况下，渲染的结果应保持一直，即shouldComponentUpdate应当返回false。<br>  一个典型的非纯组件是使用了随机数或日期等函数：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> RandomNumber = () =&gt; &lt;span&gt;&#123;Math.random&#125;&lt;/span&gt;;</span><br><span class="line"><span class="keyword">let</span> Clock = () =&gt; &lt;span&gt;&#123;Date.time()&#125;&lt;/span&gt;;</span><br></pre></td></tr></table></figure></p>
<p>  非纯组件具备向上的“传染性”，即一个包含非纯组件的组件必须是非纯组件，依然沿组件树结构向上。由于非纯组件无法通过shouldComponentUpdate优化渲染性能且具备传染性，因此要避免在非顶层或路由组件中使用。<br>  如果需要在组件树的某个节点使用随机数、日期等非纯的数据，应当由顶层组件生成这个值并通过props传递下来。对于使用Redux等应用状态管理的系统，可以在应用状态中存在相关的值（如Redux使用Action Creator生成这些值并通过Action和reducer更新到store中）。</p>
<p>· [强制]禁止为继承自PureComponent的组件编写shouldCOmponentUpdate实现。<br>  参考<a href="https://github.com/facebook/react/issues/9239" target="_blank" rel="external">React的相关Issue</a>，在React的实现中，PureComponent并不是直接实现shouldComponentUpdate，而是添加一个isReactPureComponent的标记，由CompositeComponent通过识别这个标记实现相关的逻辑。因此在PureComponent上自定义shouldComponentUpdate并无法享受super.shouldComponentUpdate的逻辑复用，会使得这个继承关系失去意义。</p>
<p>· [强制]为非继承自PureComponent的纯组件实现should方法。<br>  shouldComponentUpdate方法在React的性能中扮演者至关重要的角色，纯组件必定能通过props和state的变化来决定是否进行渲染，因此如果组件为纯组件且不继承shouldComponentUpdate，则应当有自己的shouldComponentUpdate实现来减少不必要的渲染。</p>
<p>· [建议]为函数组件添加PureComponent能力。<br>  函数组件并非一定是纯组件，因此其shouldComponentUpdate的实现为true，这可能导致额外的无意义渲染，因此推荐使用高阶组件为其添加shouldComponentUpdate的相关逻辑。<br>  推荐使用react-pure-stateless-component库实现这一功能。</p>
<p>· [建议]使用@autobind进行事件处理方法与this的绑定。<br>  由于PureComponent使用<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="external">shallowEqual</a>进行是否渲染的判断，如果在JSX中使用bind或箭头函数绑定this会造成子组件每次获取的函数都是一个新的引用，这破坏了shouldComponentUpdate的逻辑，引入了无意义的重复渲染，因此需要在render调用之前就将事件处理方法与this绑定，在每次render调用中获取同样的引用。<br>  当前比较流行的事前绑定this的方法有2种，其一使用类属性的方法：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    onClick = e =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  其二使用@autobind的装饰器：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    onClick(e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  使用类属性语法虽然可以避免引入一个autobind的实现，但存在一定的缺陷：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 对于新手不容易理解函数内部的this定义。</span><br><span class="line">· 无法在函数是使用其他的装饰器（如memoize、deprecated或检验相关的逻辑等）。</span><br><span class="line"></span><br><span class="line">因此，推荐使用@autobind装饰器实现this的事先绑定，推荐使用core-decorators库提供的相关装饰器实现。</span><br></pre></td></tr></table></figure></p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>· [强制]没有子节点的非DOM组件使用自闭合语法。<br>  对于DOM节点，按照HTML编码规范相关规则进行闭合，其中void element使用自闭合语法。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo&gt;&lt;/Foo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]保持起始和结束标签在同一层缩进。<br>  对于标签前面有其他语句（如return的情况，使用括号进行换行和缩进）。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">            &lt;span&gt;Hello World&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span&gt;Hello World&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  对于直接return的函数组件，可以直接使用括号而省去大括号和return关键字：<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Message = () =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;span&gt;Hello World&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于多属性需要换行，从第一个属性开始，每个属性一行。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有子节点</span></span><br><span class="line">&lt;SomComponent</span><br><span class="line">    longProp=&#123;longProp&#125;</span><br><span class="line">    anotherLongProp=&#123;anotherLongProp&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有子节点</span></span><br><span class="line">&lt;SomeComponent</span><br><span class="line">    longProp=&#123;longProp&#125;</span><br><span class="line">    anotherLongProp=&#123;anotherLongProp&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;SomeChild /&gt;</span><br><span class="line">    &lt;SomeChild /&gt;</span><br><span class="line">&lt;/SomeComponent&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]以字符串字面量作为值的属性使用双引号（”），在其他类型表达式中的字符串使用单引号（’）。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span> /&gt;</span><br><span class="line">&lt;Foo style=&#123;&#123;width: "20px"&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">&lt;Foo bar="bar" /&gt;</span><br><span class="line">&lt;Foo style=&#123;&#123;width: '20px'&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]自闭合标签的/&gt;前添加一个空格。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo bar=<span class="string">"bar"</span>/&gt;</span><br><span class="line">&lt;Foo bar="bar"  /&gt;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">&lt;Foo bar="bar" /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于值为true的属性，省去值部分。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&lt;Foo visible=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">&lt;Foo visible /&gt;</span><br></pre></td></tr></table></figure></p>
<p>· [强制]对于需要使用key的场合，提供一个唯一标识作为key属性的值，禁止使用可能会变化的属性（如索引）。<br>  key属性是React在进行列表更新时的重要属性，如该属性会发生变化，渲染的性能和正确性都无法得到保证。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">&#123;list.map((item, index) =&gt; &lt;Foo key=&#123;index&#125; &#123;...item&#125; /&gt;)&#125;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">&#123;list.map(item =&gt; &lt;Foo key=&#123;item.id&#125; &#123;...item&#125; /&gt;)&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [建议]避免在JSX的属性值中直接使用对象和函数表达式。<br>  PureComponent使用<a href="https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/shallowEqual.js" target="_blank" rel="external">shallowEqual</a>对props和state进行比较来决定是否需要渲染，而在JSX的属性值中使用对象、函数表达式会造成每一次的对象引用不同，从而shallowEqual会返回false，导致不必要的渲染。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnButton</span> </span>&#123;</span><br><span class="line">    alertMessage(message) &#123;</span><br><span class="line">        alert(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;button type="button" onClick=&#123;() =&gt; this.alertMessage(this.props.message)&#125;&gt;提示&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnButton</span> </span>&#123;</span><br><span class="line">    @autobind</span><br><span class="line">    alertMessage() &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.props.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;button type="button" onClick=&#123;this.alertMessage&#125;&gt;提示&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>· [建议]将JSX的层级控制在3层以内。<br>  JSX提供了基于组件的便携的复用形式，因此可以通过将结构中的一部分封装为一个函数组件来很好地拆分大型复杂的结构。层次过深的结构会带来过多缩进、可读性下降等缺点。如同控制函数内代码行数和分支层级一样，对JSX的层级进行控制可以有效提升代码的可维护性。<br>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">let</span> list = (&#123;items&#125;) = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">             items.map(item =&gt; &#123;</span><br><span class="line">                 &lt;li&gt;</span><br><span class="line">                     &lt;header&gt;</span><br><span class="line">                         &lt;h3&gt;&#123;item.title&#125;&lt;/h3&gt;</span><br><span class="line">                         &lt;span&gt;&#123;item.subtitle&#125;&lt;/span&gt;</span><br><span class="line">                     &lt;/header&gt;</span><br><span class="line">                     &lt;section&gt;&#123;item.content&#125;&lt;/section&gt;</span><br><span class="line">                     &lt;footer&gt;</span><br><span class="line">                         &lt;span&gt;&#123;item.author&#125;&lt;/span&gt;@&lt;time&gt;&#123;time.postTime&#125;&lt;/time&gt;</span><br><span class="line">                     &lt;/footer&gt;</span><br><span class="line">                 &lt;/li&gt;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">let</span> Header = (&#123;title, subtitle&#125;) =&gt; (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;h3&gt;&#123;title&lt;/h3&gt;</span><br><span class="line">        &lt;span&gt;&#123;subtitle&lt;/span&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Content = (&#123;content&#125;) =&gt; &lt;section&gt;&#123;content&#125;&lt;/section&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Footer = (&#123;author, postTime&#125;) =&gt; (</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;span&gt;&#123;author&#125;&lt;/span&gt;@&lt;time&gt;&#123;postTime&#125;&lt;/time&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Item = (&#123;item&#125;) =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Header &#123;...item&#125; /&gt;</span><br><span class="line">        &lt;Content &#123;...item&#125; /&gt;</span><br><span class="line">        &lt;Footer &#123;...item&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">let List = (&#123;items&#125;) =&gt; (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;items.map(Item)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用Chrome插件有哪些？]]></title>
      <url>http://yoursite.com/2017/08/08/chrome-common-plugin/</url>
      <content type="html"><![CDATA[<p>作为一名web开发者，会接触到很多开发工具，今天就来说说常用的chrome插件，利用这些插件给平时的工作、开发带来很大的便利。</p>
<h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><p>首选介绍这几个插件在浏览器使用过程中会有一些优化，它会给你带来什么样的体验呢？赶快去体验吧~</p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>Momentum插件用来替换Chrome新标签页内容，每天能看到不同优美的风景图片和精彩的格言。打开浏览器就能看到这么激励人心的内容，有木有给你的工作和生活带来动力？除此之外，该插件还提供了其他重要的功能，可以设置天气信息，待办事件记录，日常事务等等。</p>
<p><img src="/assets/2017-08-08-momentum.png" alt="momentum"></p>
<h3 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h3><p>Chrome浏览器虽然访问页面很流畅，但是消耗内存也很大。OneTab字面意思即一个tab页面，当你用浏览器打开多个标签页，也许很多重要的内容没来得及看但又不想把它立即关掉，这时候你可以用OneTab插件来管理打开的tab标签页内容了。单击OneTab图标会将所有标签页转换成一个列表，在某个标签页可以选择左侧或右侧标签页放到OneTab列表页中。当再次访问这些标签页时可以从从这里恢复它们。将标签页放置到OneTab中，浏览器打开的标签页减少了，占用系统内存相应减少。</p>
<p><img src="/assets/2017-08-08-onetab.png" alt="onetab"></p>
<h3 id="Proxy-SwitchySharp"><a href="#Proxy-SwitchySharp" class="headerlink" title="Proxy SwitchySharp"></a>Proxy SwitchySharp</h3><p>由于国内某些原因（你懂得），常常不能访问国外一些网站，这时候要访问这些内容时需要借助一些工具才能达到。这些工具就是代理，采用了代理浏览器则会通过代理去请求资源，从而绕开一些壁垒，请求到相应资源。Proxy SwitchSharp就是用来管理浏览器代理，可以将代理信息在这里设置从而达到“科学上网”。</p>
<p><img src="/assets/2017-08-08-proxy-switchysharp.png" alt="proxy switchysharp"></p>
<h3 id="一键管理"><a href="#一键管理" class="headerlink" title="一键管理"></a>一键管理</h3><p>也许你的浏览器安装了不止一个插件，当你想把某个插件禁用或开启，没有安装此插件则需要到浏览器扩展程序页面中操作。一键管理插件会将浏览器安装过的所有插件放在一个控制面板中展示，所有插件一键开启或禁止，也可以针对某个插件开启或禁止。</p>
<p><img src="/assets/2017-08-08-onekeyplugin.png" alt="onekeyplugin"></p>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>我们常常会在电脑上访问的页面用手机去浏览，比如开发测试无线页面效果，一般做法是将浏览器上访问的地址用手机浏览器打开，这样难以避免输入一串网址的烦恼，而且容易出错。有了这个插件，可以直接用手机扫描插件生成的二维码，从而快速访问到页面内容。</p>
<p><img src="/assets/2017-08-08-qrcode.png" alt="qrcode"></p>
<h2 id="Github相关"><a href="#Github相关" class="headerlink" title="Github相关"></a>Github相关</h2><p>github对于一个开发者来说并不陌生，github作为一个代码托管的在线服务，许多优秀的开发资源在这里涌现。Github最丰富的资源就是代码和文档，开发者可以从这里学习和利用到很多资源。下面介绍这几款与github相关的插件。</p>
<h3 id="Avatars-for-Github"><a href="#Avatars-for-Github" class="headerlink" title="Avatars for Github"></a>Avatars for Github</h3><p>登录用户访问github网站首页，呈现的是许多关注用户的一些动态信息，比如创建代码仓库、关注代码仓库、提及到代码、留言评论，网站默认不显示用户头像，只显示出用户名。人通常对图片比文字敏感，看到图片能更快获取到信息。使用了这个插件就能让页面中涉及的用户头像展示出来，浏览信息更加引起用户的注意力。</p>
<p><img src="/assets/2017-08-08-avatars-for-github.png" alt="avatars for github"></p>
<h3 id="Insight-io-for-Github"><a href="#Insight-io-for-Github" class="headerlink" title="Insight.io for Github"></a>Insight.io for Github</h3><p>用户在访问一个仓库的源代码时通常是在各个目录和文件中来回切换，需要在页面中点击相应链接跳转才能实现。现在把这款强大的代码组织管理插件装上，你会越来越爱上这款插件。开启这个插件，在当前页面会展现代码的目录结构，单页面访问任何文件内容，展示文件的具体内容结构以及跨代码仓库查看文件内容引用。</p>
<p><img src="/assets/2017-08-08-insight.io-for-github.png" alt="insight.io for github"></p>
<h3 id="Sourcegraph-for-Github"><a href="#Sourcegraph-for-Github" class="headerlink" title="Sourcegraph for Github"></a>Sourcegraph for Github</h3><p>装上这个插件当你在浏览代码、提交信息、diff信息时github像一个IDE一样，代码语法高亮显示，可以进行代码高级查找、跳转到代码定义所在行、发现代码相关引用。无论功能和效果都比上一个插件强大，不过使用这个插件会先打开一个新页面，然后加载内容展示。</p>
<p><img src="/assets/2017-08-08-sourcegraph-for-github.png" alt="sourcegraph for github"></p>
<h3 id="octotree"><a href="#octotree" class="headerlink" title="octotree"></a>octotree</h3><p>启动这个插件，访问代码仓库时会展现代码结构树，便于代码浏览。</p>
<p><img src="/assets/2017-08-08-octotree.png" alt="octotree"></p>
<h3 id="Github-Markdown-Menu"><a href="#Github-Markdown-Menu" class="headerlink" title="Github Markdown Menu"></a>Github Markdown Menu</h3><p>Github Markdown Menu会给readme或者Markdown文件生成一个导航目录。</p>
<p><img src="/assets/2017-08-08-github-markdown-menu.png" alt="github markdown menu"></p>
<h2 id="前端框架相关"><a href="#前端框架相关" class="headerlink" title="前端框架相关"></a>前端框架相关</h2><p>Angular、React、Vue号称当前前端主流的三大框架，下面这几款插件就与它们息息相关，运用这些插件在程序调试过程中得心应手。</p>
<h3 id="AngularJS-Batarang"><a href="#AngularJS-Batarang" class="headerlink" title="AngularJS Batarang"></a>AngularJS Batarang</h3><p>这个插件为AngularJS框架扩展浏览器开发者工具功能，用来调试angularjs应用、性能测试。</p>
<p><img src="/assets/2017-08-08-angularjs-batarang.png" alt="angularjs batarang"></p>
<h3 id="React-Developer-Tools"><a href="#React-Developer-Tools" class="headerlink" title="React Developer Tools"></a>React Developer Tools</h3><p>该插件为开源React.js JavaScript库扩展浏览器开发者工具功能，方便用户查看页面组件树结构关系。你可以在控制面板下选中组件展示其组件属性，也可以改变组件的pros和state内容。</p>
<p><img src="/assets/2017-08-08-react-developer-tools.png" alt="react developer tools"></p>
<h3 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h3><p>这个插件为Vue.js框架扩展浏览器开发者工具功能，用来调试Vue.js应用程序，展示组件结构，跟踪组件数据流。</p>
<p><img src="/assets/2017-08-08-vue.js-devtools.png" alt="vue.js devtools"></p>
<h2 id="开发工具相关"><a href="#开发工具相关" class="headerlink" title="开发工具相关"></a>开发工具相关</h2><p>除了上面这几款实用的插件，还有很多优秀的开发工具插件，下面列举我平时使用过的一些用于开发的插件。</p>
<h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>Postman并不是Chrome扩展程序，而是一个Chrome应用，这里把它列出来在于其在网络请求方面功能很强大。该插件可用来做API开发调试，支持多种请求方式。</p>
<p><img src="/assets/2017-08-08-postman.png" alt="postman"></p>
<h3 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h3><p>在开发网络应用程序时，开启这个插件文件内容更新其展示页面会同步更新。</p>
<p><img src="/assets/2017-08-08-livereload.png" alt="livereload"></p>
<h3 id="JSONView"><a href="#JSONView" class="headerlink" title="JSONView"></a>JSONView</h3><p>可用于校验json文件内容，格式化高亮展现json文件内容。</p>
<p><img src="/assets/2017-08-08-jsonview.png" alt="jsonview"></p>
<h3 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a>FeHelper</h3><p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色、Ajax接口调试。</p>
<p><img src="/assets/2017-08-08-fehelper.png" alt="fehelper"></p>
<h3 id="Sizzy"><a href="#Sizzy" class="headerlink" title="Sizzy"></a>Sizzy</h3><p>响应式网站调试工具，支持多种机型和尺寸。</p>
<p><img src="/assets/2017-08-08-sizzy.png" alt="sizzy"></p>
<h3 id="Distill-Web-Monitor"><a href="#Distill-Web-Monitor" class="headerlink" title="Distill Web Monitor"></a>Distill Web Monitor</h3><p>Distill在您的浏览器上运行，检查监控的页面有无变更。在侦测到变更时立即发出通知。</p>
<p><img src="/assets/2017-08-08-distill-web-monitor.png" alt="disll web monitor"></p>
<h3 id="Web-Developer"><a href="#Web-Developer" class="headerlink" title="Web Developer"></a>Web Developer</h3><p>一个拥有丰富功能的网页开发工具。</p>
<p><img src="/assets/2017-08-08-web-developer.png" alt="web developer"></p>
<h3 id="HTML5-Outliner"><a href="#HTML5-Outliner" class="headerlink" title="HTML5 Outliner"></a>HTML5 Outliner</h3><p>生成一个带有标题和区域元素的html5页面轮廓结构。</p>
<p><img src="/assets/2017-08-08-html5-outliner.png" alt="html5 outliner"></p>
<h3 id="Open-SEO-Stats"><a href="#Open-SEO-Stats" class="headerlink" title="Open SEO Stats"></a>Open SEO Stats</h3><p>显示当前网页的排名和 SEO 统计数据，主要包括 Alexa、Compete、Quantcast 排名，以及外链、索引数、IP 位置、Whois、SNS、缓存等。</p>
<p><img src="/assets/2017-08-08-open-seo-stats.png" alt="open seo stats"></p>
<h3 id="Humans-txt"><a href="#Humans-txt" class="headerlink" title="Humans.txt"></a>Humans.txt</h3><p>如果网站存在humans.txt内容，可用来展现其具体内容。</p>
<p><img src="/assets/2017-08-08-humans.png" alt="humans"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一次重构静态网站浅谈]]></title>
      <url>http://yoursite.com/2017/07/29/refactor-static-website/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>静态网站顾名思义是由静态页面构成的网站，不涉及到后端数据库系统，页面中的内容在制作的时候就已经写好了。若需要去改某个页面的内容则需要找到该页面的模板文件修改。</p>
<p>最近收到了一个大学老师的消息，问我是否有空能帮她做个课题申报项目网站。我按照了项目开发的流程先打听了老师的项目需求，老师说该项目需求与在大学期间帮她做的那个课题申报项目类似，具体需求内容在此不多介绍了，主要是课题的一些相关内容需要采用网站的形式展示出来。</p>
<p>通过收藏夹打开了大学期间做的那个网站，网站挂靠在校园的服务器上，还能完好的访问。整个网站内容大致有7大板块，每个板块由侧边栏目录导航内容和右侧内容显示区块组成，整个网站大概有30个静态页面。我习惯性的会打开浏览器的控制台看页面结构和源码，发现页面中的资源引入和跳转链接全都采用了相对路径，出现了很多以.和..构成的链接，对我这种有整洁癖好的人引起了强迫症。</p>
<p>老师把四年前的源代码发给了我，我细看源码网站的内容由一个一个静态html页面组成，没有公共的模块内容，页面中的顶部图、导航条、版权栏都分散在各个页面中，没有独立出来。新的需求同样有这三块的内容，修改一处意味着每个页面都得改一次，严重影响了开发效率。基于此寻思着新的解决方案搭建这个静态网站。</p>
<h2 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h2><p>首先想到的是做这个静态网站能否像写博客那样，利用markdown语法书写各个页面的内容。但考虑到页面中的内容除了纯文本内容外，还包含了pdf文档、视频内容。对整个网站内容大致细分了各个组成模块，发现可以抽出一个基础的模板布局文件，将网站的顶部图片、导航条、版权栏内容单独抽出来，再分别引入到各个页面中，浏览pdf文档与观看视频功能可以制作成组件，在页面中通过使用组件就能方便快捷搭建内容。</p>
<p>基于上述的需求诉求，我采用了模板引擎来完成这些内容。模板引擎是个什么东西呢？模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p>
<p>模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。置换型模板引擎实现简单，但其效率低下，无法满足高负载的应用需求（比如有海量访问的网站），因此还出现了“解释型”模板引擎和“编译型”模板引擎等。模板引擎又分为前端模板引擎和后端模板引擎。后端模板引擎针对各种语言分别有相对应的模板引擎，像PHP语言比较知名的smarty，Java语言Velocity，Python语言Django等等。常见流行的前端模板引擎有artTemplate、Mustache、HandlebarsJS、EJS、Jade（新名pug）、Swig等等。</p>
<p>静态网站不涉及到后端内容，选用前端模板即可解决问题。那这么多前端模板引擎如何选择才能找到一个合适的模板引擎呢？在开发中有良好的运行调试能力，支持模板继承和文件引入，支持作用域变量和判断循环条件语句，拥有简洁的语法在一定条件下能减少代码书写量，拥有上述这些特点的模板引擎都能支撑起业务开发，于是我选择了pug模板引擎。</p>
<h2 id="实践思路"><a href="#实践思路" class="headerlink" title="实践思路"></a>实践思路</h2><h3 id="目录规划"><a href="#目录规划" class="headerlink" title="目录规划"></a>目录规划</h3><p>对一个静态网站来说，资源包含静态模板页面、样式文件、静态资源（如图片、视频、文档等等）。如何设计整个网站的目录结构对开发效率来说有很大的影响。目前大体上网站的目录结构有两种分类方式，一种是根据功能来划分目录结构，比如某个页面实现所需要的业务组件、样式都放在同一个目录里，这种对于业务功能比较复杂类应用来说尤为方便，资源查找和引用一目了然；另一种是根据文件类型来划分目录结构，这种对于网站文件管理比较方便。</p>
<p>根据这个静态网站的需求来开发，网站内容偏展示，不涉及复杂的页面交互逻辑，以文件类型为目录结构规划网站内容。</p>
<p><img src="/assets/2017-07-project-directory.png" alt="目录结构图"></p>
<h3 id="开发细节"><a href="#开发细节" class="headerlink" title="开发细节"></a>开发细节</h3><p>得益于pug简洁的模板语法和强大的模板功能，pug在这个项目中发挥了很大作用。每个页面都是继承自base layout，其中base layout包括页面banner、nav、footer公用的组件，nav的状态可以通过在具体页面中传入变量实现。每个页面根据实际情况可以划分为侧边导航栏组件和内容区域，从而组成一个个具体的页面。</p>
<p>pdf文件浏览采用开源的pdf.js库，能够实现跨平台在线浏览pdf文件内容。视频文件考虑到文件格式兼容性和在线存储，使用了传统的flash流式播放。封装了这两个组件，在使用的时候采用参数传入的方式来调动功能，从而达到复用。</p>
<p>采用这种继承layout和组件形式开发，节省了很多开发工作量，开发效率得到很大提升，并且易于维护。</p>
<h3 id="构建部署"><a href="#构建部署" class="headerlink" title="构建部署"></a>构建部署</h3><p>现在每个网站的开发、测试、上线离不开一个构建部署脚本。node.js的不断发展，生态系统日益壮大，有很多方便快捷的工具可以用于开发构建。本项目用到了将pug模板编译成html内容，css和js文件压缩，浏览器同步自动更新构建工具，基于文件流和任务式自动化构建工具gulp.js，能够简单高效的完成网站的构建与部署。</p>
<p><img src="/assets/2017-07-29-work-stream.png" alt="构建流程图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>完成整个网站开发涉及到了方方面面，一点一滴的积累和实践，得到了成长，收获了快乐。</p>
]]></content>
    </entry>
    
  
  
</search>
